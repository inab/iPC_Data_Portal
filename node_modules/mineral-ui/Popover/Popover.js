'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.componentTheme = undefined;

var _jsx = function () { var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; return function createRawReactElement(type, props, key, children) { var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = {}; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactPopper = require('react-popper');

var _styles = require('../styles');

var _utils = require('../utils');

var _ModifiersContext = require('../Dialog/ModifiersContext');

var _ModifiersContext2 = _interopRequireDefault(_ModifiersContext);

var _EventListener = require('../EventListener');

var _EventListener2 = _interopRequireDefault(_EventListener);

var _Portal = require('../Portal');

var _Portal2 = _interopRequireDefault(_Portal);

var _PopoverTrigger = require('./PopoverTrigger');

var _PopoverTrigger2 = _interopRequireDefault(_PopoverTrigger);

var _PopoverContent = require('./PopoverContent');

var _PopoverContent2 = _interopRequireDefault(_PopoverContent);

var _PopoverArrow = require('./PopoverArrow');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var bpfrpt_proptype_RenderFn = _propTypes2.default.func;
var componentTheme = exports.componentTheme = function componentTheme(baseTheme) {
  return _extends({}, (0, _PopoverArrow.componentTheme)(baseTheme), (0, _PopoverContent.componentTheme)(baseTheme), baseTheme);
};

var Root = (0, _styles.createStyledComponent)(_reactPopper.Manager, {
  color: null,
  display: 'inline-block'
}, {
  displayName: 'Popover',
  forwardProps: ['tag'],
  rootEl: 'span'
});

/**
 * Popovers float over page content and hold supporting information or user controls.
 */

var Popover = function (_Component) {
  _inherits(Popover, _Component);

  function Popover() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Popover);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Popover.__proto__ || Object.getPrototypeOf(Popover)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      isOpen: Boolean(_this.props.defaultIsOpen)
    }, _this.id = _this.props.id || 'popover-' + (0, _utils.generateId)(), _this.getStateAndHelpers = function () {
      return {
        state: {
          isOpen: _this.getControllableValue('isOpen')
        },
        helpers: {
          close: _this.close,
          focusTrigger: _this.focusTrigger,
          open: _this.open,
          toggleOpen: _this.toggleOpen
        }
      };
    }, _this.setTriggerRef = function (node) {
      var triggerRef = _this.props.triggerRef;


      _this.popoverTrigger = node;
      triggerRef && triggerRef(node);
    }, _this.setContentRef = function (node) {
      _this.popoverContent = node;
    }, _this.getContentProps = function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var contentId = _this.getContentId();
      var _this$props = _this.props,
          content = _this$props.content,
          hasArrow = _this$props.hasArrow,
          modifiers = _this$props.modifiers,
          placement = _this$props.placement,
          subtitle = _this$props.subtitle,
          title = _this$props.title;


      return _extends({}, props, {
        hasArrow: hasArrow,
        id: contentId,
        modifiers: modifiers,
        placement: placement,
        ref: _this.setContentRef,
        subtitle: subtitle,
        tabIndex: 0,
        title: title,
        onBlur: (0, _utils.composeEventHandlers)(content && content.props && content.props.onBlur, _this.onBlur)
      });
    }, _this.renderContent = function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _this$props2 = _this.props,
          content = _this$props2.content,
          usePortal = _this$props2.usePortal;

      var popoverContent = void 0;

      if ((0, _utils.isRenderProp)(content)) {
        popoverContent = content(_extends({}, _this.getStateAndHelpers(), {
          props: _this.getContentProps(props)
        }));
      } else {
        popoverContent = _react2.default.createElement(
          _PopoverContent2.default,
          _this.getContentProps(props),
          content
        );
      }

      if (usePortal) {
        popoverContent = _jsx(_Portal2.default, {}, void 0, popoverContent);
      }

      return popoverContent;
    }, _this.getContentId = function () {
      return _this.id + '-content';
    }, _this.getTriggerProps = function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var isOpen = _this.getControllableValue('isOpen');
      var contentId = _this.getContentId();
      var _this$props3 = _this.props,
          children = _this$props3.children,
          cursor = _this$props3.cursor,
          disabled = _this$props3.disabled;


      var child = void 0,
          childDisabled = void 0;
      if (!(0, _utils.isRenderProp)(children)) {
        child = children ? _react.Children.only(children) : undefined;
        childDisabled = child && child.props.disabled !== undefined;
      }

      return _extends({}, (0, _utils.isRenderProp)(children) ? props : {}, {
        'aria-describedby': contentId,
        'aria-disabled': disabled,
        'aria-expanded': isOpen,
        'aria-owns': contentId,
        children: child,
        cursor: cursor,
        disabled: child && childDisabled ? childDisabled : disabled,
        ref: _this.setTriggerRef,
        role: 'button'
      }, !(0, _utils.isRenderProp)(children) ? props : {}, {
        onBlur: (0, _utils.composeEventHandlers)(props.onBlur, _this.onBlur),
        onClick: !disabled ? (0, _utils.composeEventHandlers)(props.onClick, _this.toggleOpen) : undefined
      });
    }, _this.renderTrigger = function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var children = _this.props.children;


      if ((0, _utils.isRenderProp)(children)) {
        return children(_extends({}, _this.getStateAndHelpers(), {
          props: _this.getTriggerProps(props)
        }));
      }

      var child = _react.Children.only(children);
      return _react2.default.createElement(_PopoverTrigger2.default, _this.getTriggerProps(_extends({}, child.props, { children: child })));
    }, _this.onBlur = function (event) {
      var isOpen = _this.getControllableValue('isOpen');
      if (isOpen && _this.isEventOutsideComponent(event)) {
        _this.close(event);
      }
    }, _this.close = function (event) {
      if (_this.isControlled('isOpen')) {
        _this.closeActions(event);
      } else {
        _this.setState(function () {
          return { isOpen: false };
        }, function () {
          _this.closeActions(event);
        });
      }
    }, _this.closeActions = function (event) {
      var _this$props4 = _this.props,
          focusTriggerOnClose = _this$props4.focusTriggerOnClose,
          onClose = _this$props4.onClose;

      onClose && onClose(event);
      var isOpen = _this.getControllableValue('isOpen');
      !isOpen && focusTriggerOnClose && _this.focusTrigger();
    }, _this.focusTrigger = function () {
      var node = (0, _reactDom.findDOMNode)(_this.popoverTrigger); // eslint-disable-line react/no-find-dom-node
      if (node && node.firstChild && node.firstChild instanceof HTMLElement) {
        node.firstChild.focus();
      }
    }, _this.handleDocumentClick = function (event) {
      if (_this.isEventOutsideComponent(event)) {
        _this.close(event);
      }
    }, _this.handleDocumentKeydown = function (event) {
      if (event.key === 'Escape') {
        event.preventDefault();
        _this.close(event);
      }
    }, _this.isEventOutsideComponent = function (event) {
      /* eslint-disable react/no-find-dom-node */
      var usePortal = _this.props.usePortal;

      var node = (0, _reactDom.findDOMNode)(_this);
      var popoverContentNode = (0, _reactDom.findDOMNode)(_this.popoverContent);

      var target = event.type === 'blur' && event.relatedTarget && popoverContentNode === event.target ? event.relatedTarget : event.target;

      if (usePortal) {
        return node && node instanceof HTMLElement && target && target instanceof HTMLElement && !node.contains(target) && popoverContentNode && popoverContentNode instanceof HTMLElement && !popoverContentNode.contains(target);
      } else {
        return node && node instanceof HTMLElement && target && target instanceof HTMLElement && !node.contains(target);
      }
    }, _this.open = function (event) {
      if (_this.isControlled('isOpen')) {
        _this.openActions(event);
      } else {
        _this.setState(function () {
          return { isOpen: true };
        }, function () {
          _this.openActions(event);
        });
      }
    }, _this.openActions = function (event) {
      _this.focusTrigger();
      _this.props.onOpen && _this.props.onOpen(event);
    }, _this.toggleOpen = function (event) {
      var isOpen = _this.getControllableValue('isOpen');
      if (isOpen) {
        _this.close(event);
      } else {
        _this.open(event);
      }
    }, _this.isControlled = function (prop) {
      return _this.props.hasOwnProperty(prop);
    }, _this.getControllableValue = function (key) {
      return _this.isControlled(key) ? _this.props[key] : _this.state[key];
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Popover, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          modifiers = _props.modifiers,
          restProps = _objectWithoutProperties(_props, ['modifiers']);

      var isOpen = this.getControllableValue('isOpen');

      var rootProps = _extends({}, restProps, {
        tag: 'span'
      });

      return _jsx(_ModifiersContext2.default.Consumer, {}, void 0, function (contextModifiers) {
        rootProps.modifiers = modifiers || contextModifiers;

        return _react2.default.createElement(
          Root,
          rootProps,
          _this2.renderTrigger(),
          isOpen && _this2.renderContent(),
          isOpen && _jsx(_EventListener2.default, {
            listeners: [{
              target: 'document',
              event: 'click',
              handler: _this2.handleDocumentClick,
              options: true
            }, {
              target: 'document',
              event: 'keydown',
              handler: _this2.handleDocumentKeydown,
              options: true
            }]
          })
        );
      });
    }
  }]);

  return Popover;
}(_react.Component);

Popover.defaultProps = {
  focusTriggerOnClose: true,
  hasArrow: true,
  placement: 'bottom'
};
exports.default = Popover;
Popover.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * Trigger for the Popover. Optionally provides custom rendering control.
   * See the [custom trigger example](/components/popover#custom-trigger)
   * and our [render props guide](/render-props).
   */
  children: _propTypes2.default.oneOfType([function () {
    return (typeof React$Node === 'function' ? _propTypes2.default.instanceOf(React$Node) : _propTypes2.default.any).apply(this, arguments);
  }, function () {
    return (typeof RenderFn === 'function' ? _propTypes2.default.instanceOf(RenderFn) : _propTypes2.default.any).apply(this, arguments);
  }]).isRequired,

  /**
   * Content of the Popover. Optionally provides custom rendering control.
   * See the [custom content example](/components/popover#custom-content)
   * and our [render props guide](/render-props).
   */
  content: _propTypes2.default.oneOfType([function () {
    return (typeof $FlowFixMe === 'function' ? _propTypes2.default.instanceOf($FlowFixMe) : _propTypes2.default.any).apply(this, arguments);
  }, function () {
    return (typeof RenderFn === 'function' ? _propTypes2.default.instanceOf(RenderFn) : _propTypes2.default.any).apply(this, arguments);
  }]).isRequired,

  /**
   * @Private Cursor applied when hovering the popover trigger; accepts any
   * [valid CSS value](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor)
   */
  cursor: _propTypes2.default.string,

  /**
   * Open the Popover upon initialization. Primarily for use with uncontrolled
   * components.
   */
  defaultIsOpen: _propTypes2.default.bool,

  /** Disables the Popover */
  disabled: _propTypes2.default.bool,

  /**
   * Determines whether focus will be set to the trigger when the Popover is
   * closed.
   */
  focusTriggerOnClose: _propTypes2.default.bool,

  /** Include an arrow on the Popover content pointing to the trigger */
  hasArrow: _propTypes2.default.bool,

  /** Id of the Popover */
  id: _propTypes2.default.string,

  /**
   * Determines whether the Popover is open. For use with controlled components.
   */
  isOpen: _propTypes2.default.bool,

  /**
   * Plugins that are used to alter behavior. See
   * [PopperJS docs](https://popper.js.org/popper-documentation.html#modifiers)
   * for options.
   */
  modifiers: _propTypes2.default.object,

  /** Called when Popover is closed */
  onClose: _propTypes2.default.func,

  /** Called when Popover is opened */
  onOpen: _propTypes2.default.func,

  /** Placement of the Popover */
  placement: _propTypes2.default.oneOf(['auto', 'auto-end', 'auto-start', 'bottom', 'bottom-end', 'bottom-start', 'left', 'left-end', 'left-start', 'right', 'right-end', 'right-start', 'top', 'top-end', 'top-start']),

  /** Subtitle displayed under the title */
  subtitle: function subtitle() {
    return (typeof React$Node === 'function' ? _propTypes2.default.instanceOf(React$Node) : _propTypes2.default.any).apply(this, arguments);
  },

  /** Title of the Popover */
  title: function title() {
    return (typeof React$Node === 'function' ? _propTypes2.default.instanceOf(React$Node) : _propTypes2.default.any).apply(this, arguments);
  },

  /** @Private ref for the Popover trigger */
  triggerRef: _propTypes2.default.func,

  /**
   * Use a Portal to render the Popover to the body rather than as a sibling to
   * the trigger
   */
  usePortal: _propTypes2.default.bool
} : {};