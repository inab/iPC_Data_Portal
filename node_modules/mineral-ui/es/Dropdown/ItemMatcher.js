function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ItemMatcher = function ItemMatcher() {
  var _this = this;

  _classCallCheck(this, ItemMatcher);

  this.keys = '';

  this.findMatchingItem = function (items, highlightedIndex, key) {
    if (!_this.isMatchableCharacter(key)) {
      return;
    }

    _this.searchIndex = highlightedIndex === undefined ? 0 : highlightedIndex + 1;

    _this.keys += key;
    _this.resetKeysAfterDelay();

    var match = _this.findMatchingItemInRange(items, _this.searchIndex, items.length) || _this.findMatchingItemInRange(items, 0, _this.searchIndex);

    return match;
  };

  this.findMatchingItemInRange = function (items, start, end) {
    var keys = _this.keys.toLowerCase();
    for (var index = start; index < end; index++) {
      var text = items[index].text;

      if (text && typeof text === 'string' && text.toLowerCase().indexOf(keys) === 0) {
        return items[index];
      }
    }
  };

  this.resetKeysAfterDelay = function () {
    if (_this.keysTimer) {
      global.clearTimeout(_this.keysTimer);
      _this.keysTimer = null;
    }

    _this.keysTimer = global.setTimeout(function () {
      _this.keys = '';
      _this.keysTimer = null;
    }, 500);
  };

  this.isMatchableCharacter = function (key) {
    return key.length === 1 && /\S/.test(key);
  };
}

// Exclude standalone modifier keys, but allow use as combinator
// e.g. Reject standalone ALT key, but ALT+m which creates Âµ is okay
;

export default ItemMatcher;
import { bpfrpt_proptype_Item } from '../Menu/Menu';
import { bpfrpt_proptype_Items } from '../Menu/Menu';