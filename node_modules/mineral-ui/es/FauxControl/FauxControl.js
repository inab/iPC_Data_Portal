var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jsx = function () { var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; return function createRawReactElement(type, props, key, children) { var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = {}; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component, cloneElement } from 'react';
import memoizeOne from 'memoize-one';

import { createStyledComponent, getNormalizedValue, pxToEm } from '../styles';
import IconDanger from '../Icon/IconDanger';
import IconSuccess from '../Icon/IconSuccess';
import IconWarning from '../Icon/IconWarning';

// prettier-ignore
export var componentTheme = function componentTheme(baseTheme) {
  return _extends({
    FauxControl_backgroundColor: baseTheme.input_backgroundColor,
    FauxControl_borderColor: baseTheme.borderColor,
    FauxControl_borderColor_active: baseTheme.borderColor,
    FauxControl_borderColor_focus: baseTheme.borderColor,
    FauxControl_borderColor_hover: baseTheme.borderColor_theme_hover,
    FauxControl_borderRadius: baseTheme.borderRadius_1,
    FauxControl_borderWidth: '1px',
    FauxControl_boxShadow_active: '0 0 0 1px ' + baseTheme.boxShadow_focusInner + ', 0 0 0 2px ' + baseTheme.borderColor_theme_active,
    FauxControl_boxShadow_focus: '0 0 0 1px ' + baseTheme.boxShadow_focusInner + ', 0 0 0 2px ' + baseTheme.borderColor_theme_focus,
    FauxControl_color: baseTheme.color,
    FauxControl_color_placeholder: baseTheme.input_color_placeholder,
    FauxControl_color_readOnly: baseTheme.color_readOnly,
    FauxControl_fontSize: baseTheme.fontSize_ui,
    FauxControl_fontSize_small: pxToEm(12),
    FauxControl_paddingHorizontal: baseTheme.space_inset_md,
    FauxControl_paddingHorizontal_small: baseTheme.space_inset_sm,

    FauxControlIcon_marginHorizontal: baseTheme.space_inline_sm

  }, baseTheme);
};

var styles = {
  prefix: function prefix(_ref) {
    var iconStart = _ref.iconStart,
        size = _ref.size,
        baseTheme = _ref.theme;

    var theme = componentTheme(baseTheme);
    var rtl = theme.direction === 'rtl';

    var fontSize = size === 'small' ? theme.FauxControl_fontSize_small : theme.FauxControl_fontSize;
    var marginWithIcon = getNormalizedValue(theme.FauxControl_paddingHorizontal, fontSize);
    var marginWithoutIcon = getNormalizedValue(parseFloat(theme.FauxControlIcon_marginHorizontal) / 2 + 'em', fontSize);

    return _extends({
      flex: '0 0 auto',
      fontSize: fontSize,
      marginLeft: rtl ? marginWithoutIcon : iconStart ? 0 : marginWithIcon,
      marginRight: rtl ? iconStart ? 0 : marginWithIcon : marginWithoutIcon,
      whiteSpace: 'nowrap'
    }, {
      display: 'inline-block',
      maxWidth: '8em',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      wordWrap: 'normal'
    });
  },
  control: function control(_ref2) {
    var controlPropsIn = _ref2.controlPropsIn,
        controlSize = _ref2.controlSize,
        disabled = _ref2.disabled,
        hasPlaceholder = _ref2.hasPlaceholder,
        iconEnd = _ref2.iconEnd,
        iconStart = _ref2.iconStart,
        prefix = _ref2.prefix,
        readOnly = _ref2.readOnly,
        nonHtmlSize = _ref2.size,
        suffix = _ref2.suffix,
        baseTheme = _ref2.theme,
        variant = _ref2.variant;

    var theme = componentTheme(baseTheme);

    var size = controlSize || nonHtmlSize;

    if (variant) {
      // prettier-ignore
      theme = _extends({}, theme, {
        FauxControl_boxShadow_focus: '0 0 0 1px ' + theme.boxShadow_focusInner + ', 0 0 0 2px ' + theme['borderColor_' + variant + '_focus']
      });
    }

    if (controlPropsIn.variant) {
      // prettier-ignore
      theme = _extends({}, theme, {
        FauxControl_color: theme['color_' + controlPropsIn.variant]
      });
    }

    var rtl = theme.direction === 'rtl';
    var fontSize = size === 'small' ? theme.FauxControl_fontSize_small : theme.FauxControl_fontSize;
    var sizeAppropriateHorizontalPadding = size === 'small' || size === 'medium' ? theme.FauxControl_paddingHorizontal_small || theme.FauxControl_paddingHorizontal : theme.FauxControl_paddingHorizontal;
    var paddingWithoutIcon = getNormalizedValue(sizeAppropriateHorizontalPadding, fontSize);

    var color = theme.FauxControl_color;
    if (disabled) {
      color = theme.color_disabled;
    } else if (hasPlaceholder) {
      color = theme.FauxControl_color_placeholder;
    } else if (readOnly) {
      color = theme.FauxControl_color_readOnly;
    }

    // [1] - Safari and many Android browsers need this to apply the correct
    //       color to disabled controls

    var placeholderStyles = {
      color: theme.FauxControl_color_placeholder,
      WebkitTextFillColor: theme.FauxControl_color_placeholder, // [1]
      fontStyle: 'italic'
    };

    return {
      color: color,
      WebkitTextFillColor: color, // [1]
      fontSize: fontSize,
      fontStyle: hasPlaceholder ? 'italic' : null,
      outline: 0,
      paddingLeft: (iconStart || prefix) && !rtl || (iconEnd || variant || suffix) && rtl ? 0 : paddingWithoutIcon,
      paddingRight: (iconEnd || variant || suffix) && !rtl || (iconStart || prefix) && rtl ? 0 : paddingWithoutIcon,

      '&::placeholder': placeholderStyles,
      '&::-ms-input-placeholder': placeholderStyles, // Edge
      '&:-ms-input-placeholder': placeholderStyles, // IE 11

      '&::-ms-clear': {
        display: 'none'
      },

      '&:focus': {
        '& ~ div:last-child': {
          borderColor: theme.FauxControl_borderColor_focus,
          boxShadow: theme.FauxControl_boxShadow_focus
        }
      }
    };
  },
  root: function root(_ref3) {
    var disabled = _ref3.disabled,
        baseTheme = _ref3.theme,
        variant = _ref3.variant;

    var theme = componentTheme(baseTheme);
    if (variant) {
      // prettier-ignore
      theme = _extends({}, theme, {
        FauxControl_borderColor_hover: theme['borderColor_' + variant + '_hover'],
        FauxControl_boxShadow_active: '0 0 0 1px ' + theme.boxShadow_focusInner + ', 0 0 0 2px ' + theme['borderColor_' + variant + '_active'],
        FauxControl_boxShadow_focus: '0 0 0 1px ' + theme.boxShadow_focusInner + ', 0 0 0 2px ' + theme['borderColor_' + variant + '_focus']
      });
    }

    return {
      position: 'relative',
      zIndex: 1,

      '&:hover': {
        '& > div:last-child': {
          borderColor: !disabled ? theme.FauxControl_borderColor_hover : null
        }
      },

      '&:focus': {
        '& > div:last-child': {
          borderColor: !disabled ? theme.FauxControl_borderColor_focus : null,
          boxShadow: !disabled ? theme.FauxControl_boxShadow_focus : null
        }
      },

      '&:active': {
        '& > div:last-child': {
          borderColor: theme.FauxControl_borderColor_active,
          boxShadow: disabled ? 'none' : theme.FauxControl_boxShadow_active
        }
      }
    };
  },
  suffix: function suffix(_ref4) {
    var iconEnd = _ref4.iconEnd,
        size = _ref4.size,
        baseTheme = _ref4.theme,
        variant = _ref4.variant;

    var theme = componentTheme(baseTheme);
    var rtl = theme.direction === 'rtl';

    var fontSize = size === 'small' ? theme.FauxControl_fontSize_small : theme.FauxControl_fontSize;
    var marginWithIcon = getNormalizedValue(theme.FauxControl_paddingHorizontal, fontSize);
    var marginWithoutIcon = getNormalizedValue(parseFloat(theme.FauxControlIcon_marginHorizontal) / 2 + 'em', fontSize);

    return _extends({
      flex: '0 0 auto',
      fontSize: fontSize,
      marginLeft: rtl ? iconEnd || variant ? 0 : marginWithIcon : marginWithoutIcon,
      marginRight: rtl ? marginWithoutIcon : iconEnd || variant ? 0 : marginWithIcon,
      whiteSpace: 'nowrap'
    }, {
      display: 'inline-block',
      maxWidth: '8em',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      wordWrap: 'normal'
    });
  },
  underlay: function underlay(_ref5) {
    var disabled = _ref5.disabled,
        readOnly = _ref5.readOnly,
        baseTheme = _ref5.theme,
        variant = _ref5.variant;

    var theme = componentTheme(baseTheme);

    return {
      backgroundColor: disabled || readOnly ? theme.input_backgroundColor_disabled : theme.FauxControl_backgroundColor,
      borderColor: variant && !disabled && !readOnly ? theme['borderColor_' + variant] : theme.FauxControl_borderColor,
      borderRadius: theme.FauxControl_borderRadius,
      borderStyle: 'solid',
      borderWidth: theme.FauxControl_borderWidth,
      bottom: 0,
      left: 0,
      position: 'absolute',
      right: 0,
      top: 0,
      zIndex: -1
    };
  }
};

var Prefix = createStyledComponent('span', styles.prefix);
var Root = createStyledComponent('div', styles.root, {
  displayName: 'FauxControl',
  includeStyleReset: true
});
var Suffix = createStyledComponent('span', styles.suffix);
var Underlay = createStyledComponent('div', styles.underlay, {
  displayName: 'Underlay'
});

var variantIcons = {
  danger: _jsx(IconDanger, {}),
  success: _jsx(IconSuccess, {}),
  warning: _jsx(IconWarning, {})
};

function getIcons(_ref6) {
  var disabled = _ref6.disabled,
      iconStart = _ref6.iconStart,
      iconEnd = _ref6.iconEnd,
      readOnly = _ref6.readOnly,
      size = _ref6.size,
      variant = _ref6.variant,
      variantIcons = _ref6.variantIcons;

  if (disabled || readOnly) {
    return [];
  }

  var iconSize = size === 'small' ? 'medium' : pxToEm(24);
  var startIcon = iconStart && cloneElement(iconStart, {
    size: iconSize,
    key: 'iconStart'
  });

  var endIconSource = iconEnd !== null && variant ? variantIcons[variant] : iconEnd ? iconEnd : null;

  var endIcon = endIconSource && cloneElement(endIconSource, {
    size: iconSize,
    key: 'iconEnd'
  });

  return [startIcon, endIcon];
}

var createControlNode = function createControlNode(props) {
  return createStyledComponent(props.control, styles.control, {
    displayName: 'Control'
  });
};

/**
 * FauxControl
 */

var FauxControl = function (_Component) {
  _inherits(FauxControl, _Component);

  function FauxControl() {
    var _ref7;

    var _temp, _this, _ret;

    _classCallCheck(this, FauxControl);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref7 = FauxControl.__proto__ || Object.getPrototypeOf(FauxControl)).call.apply(_ref7, [this].concat(args))), _this), _this.getControlNode = memoizeOne(createControlNode, function (nextProps, prevProps) {
      return nextProps.control === prevProps.control;
    }), _temp), _possibleConstructorReturn(_this, _ret);
  }
  // Must be an instance method to avoid affecting other instances memoized keys


  _createClass(FauxControl, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          afterItems = _props.afterItems,
          beforeItems = _props.beforeItems,
          children = _props.children,
          controlPropsIn = _props.controlProps,
          disabled = _props.disabled,
          fauxControlRef = _props.fauxControlRef,
          iconEnd = _props.iconEnd,
          iconStart = _props.iconStart,
          prefixIn = _props.prefix,
          size = _props.size,
          readOnly = _props.readOnly,
          suffixIn = _props.suffix,
          variant = _props.variant,
          restProps = _objectWithoutProperties(_props, ['afterItems', 'beforeItems', 'children', 'controlProps', 'disabled', 'fauxControlRef', 'iconEnd', 'iconStart', 'prefix', 'size', 'readOnly', 'suffix', 'variant']);

      var rootProps = _extends({
        disabled: disabled,
        innerRef: fauxControlRef,
        variant: variant
      }, restProps);

      var _getIcons = getIcons({
        disabled: disabled,
        iconStart: iconStart,
        iconEnd: iconEnd,
        readOnly: readOnly,
        size: size,
        variant: variant,
        variantIcons: variantIcons
      }),
          _getIcons2 = _slicedToArray(_getIcons, 2),
          startIcon = _getIcons2[0],
          endIcon = _getIcons2[1];

      var prefixAndSuffixProps = {
        iconEnd: iconEnd,
        iconStart: iconStart,
        size: size,
        variant: variant
      };

      var prefix = prefixIn ? React.createElement(
        Prefix,
        _extends({}, prefixAndSuffixProps, { key: 'prefix' }),
        prefixIn
      ) : null;
      var suffix = suffixIn ? React.createElement(
        Suffix,
        _extends({}, prefixAndSuffixProps, { key: 'suffix' }),
        suffixIn
      ) : null;

      var controlProps = _extends({
        controlPropsIn: controlPropsIn
      }, controlPropsIn, {
        children: children,
        disabled: disabled,
        iconEnd: iconEnd,
        iconStart: iconStart,
        prefix: prefixIn,
        innerRef: controlPropsIn && controlPropsIn.controlRef,
        readOnly: readOnly
      }, controlPropsIn && controlPropsIn.htmlSize ? { controlSize: size, size: controlPropsIn.htmlSize } : { size: size }, {
        suffix: suffixIn,
        variant: variant
      });

      var Control = this.getControlNode(this.props);

      var underlayProps = { disabled: disabled, readOnly: readOnly, variant: variant };

      return React.createElement(
        Root,
        rootProps,
        beforeItems,
        startIcon,
        prefix,
        React.createElement(Control, _extends({}, controlProps, { key: 'control' })),
        suffix,
        endIcon,
        afterItems,
        React.createElement(Underlay, underlayProps)
      );
    }
  }]);

  return FauxControl;
}(Component);

export default FauxControl;
FauxControl.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Elements to display after iconEnd */
  afterItems: function afterItems() {
    return (typeof React$Node === 'function' ? PropTypes.instanceOf(React$Node) : PropTypes.any).apply(this, arguments);
  },

  /** Elements to display before iconStart */
  beforeItems: function beforeItems() {
    return (typeof React$Node === 'function' ? PropTypes.instanceOf(React$Node) : PropTypes.any).apply(this, arguments);
  },

  /** Content of control */
  children: function children() {
    return (typeof React$Node === 'function' ? PropTypes.instanceOf(React$Node) : PropTypes.any).apply(this, arguments);
  },

  /** Component that receives focus */
  control: function control() {
    return (typeof React$ComponentType === 'function' ? PropTypes.instanceOf(React$ComponentType).isRequired : PropTypes.any.isRequired).apply(this, arguments);
  },

  /** Props applied to the control */
  controlProps: PropTypes.object,

  /** Disables the source */
  disabled: PropTypes.bool,

  /** ref for the FauxControl */
  fauxControlRef: PropTypes.func,

  /** Icon located at the start of the control */
  iconStart: function iconStart() {
    return (typeof React$Element === 'function' ? PropTypes.instanceOf(React$Element) : PropTypes.any).apply(this, arguments);
  },

  /** Icon located at the end of the control */
  iconEnd: function iconEnd() {
    return (typeof React$Element === 'function' ? PropTypes.instanceOf(React$Element) : PropTypes.any).apply(this, arguments);
  },

  /** Text to display before control */
  prefix: function prefix() {
    return (typeof React$Node === 'function' ? PropTypes.instanceOf(React$Node) : PropTypes.any).apply(this, arguments);
  },

  /** Indicates that the user cannot modify the value of the source */
  readOnly: PropTypes.bool,

  /** Available sizes */
  size: PropTypes.oneOf(['small', 'medium', 'large', 'jumbo']),

  /** Text to display after control */
  suffix: function suffix() {
    return (typeof React$Node === 'function' ? PropTypes.instanceOf(React$Node) : PropTypes.any).apply(this, arguments);
  },

  /** Available variants */
  variant: PropTypes.oneOf(['success', 'warning', 'danger'])
} : {};
import PropTypes from 'prop-types';