var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

import React, { Children, cloneElement } from 'react';
import { withTheme } from '../themes';
import { createStyledComponent, pxToEm } from '../styles';
import getResponsiveStyles, { getPrevNonNull } from '../styles/getResponsiveStyles';
import Box from '../Box';

var bpfrpt_proptype_Values = PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.string]);


var getAlignment = function getAlignment(value) {
  return ['start', 'end'].indexOf(value) !== -1 ? 'flex-' + value : value;
};

var getGutterSize = function getGutterSize(theme, value) {
  return typeof value === 'number' && value !== 0 ? pxToEm(value) : theme['space_inline_' + value] || value;
};

var getIndexedValue = function getIndexedValue(property, index) {
  return property && Array.isArray(property) && index !== undefined ? property[index] : property;
};

var getJustification = function getJustification(value) {
  return ['around', 'between', 'evenly'].indexOf(value) !== -1 ? 'space-' + value : getAlignment(value);
};

var getMarginOrGutter = function getMarginOrGutter(_ref) {
  var gutterWidth = _ref.gutterWidth,
      index = _ref.index,
      margin = _ref.margin,
      marginEnd = _ref.marginEnd,
      marginHorizontal = _ref.marginHorizontal,
      marginStart = _ref.marginStart,
      start = _ref.start,
      theme = _ref.theme;

  return getIndexedValue(start ? marginStart : marginEnd, index) || getIndexedValue(marginHorizontal, index) || getIndexedValue(margin, index) || getGutterSize(theme, gutterWidth);
};

var getMarginProps = function getMarginProps(_ref2) {
  var direction = _ref2.direction,
      gutterWidth = _ref2.gutterWidth,
      theme = _ref2.theme,
      restProps = _objectWithoutProperties(_ref2, ['direction', 'gutterWidth', 'theme']);

  if (Array.isArray(direction)) {
    return direction.reduce(function (acc, _, index) {
      var value = getPrevNonNull(direction, index);

      if (value === 'row' || value === 'row-reverse') {
        pushMarginProps(_extends({
          direction: value,
          index: index,
          gutterWidth: gutterWidth,
          props: acc,
          theme: theme
        }, restProps));
      } else {
        pushMarginProps(_extends({
          index: index,
          gutterWidth: 0,
          props: acc,
          theme: theme
        }, restProps));
      }
      return acc;
    }, { marginStart: [], marginEnd: [] });
  } else if (direction === 'row' || direction === 'row-reverse') {
    var flip = direction === 'row-reverse';
    var marginProperty = flip ? 'marginStart' : 'marginEnd';

    return _defineProperty({}, marginProperty, getMarginOrGutter(_extends({}, restProps, {
      gutterWidth: gutterWidth,
      start: flip,
      theme: theme
    })));
  }
};

var pushMarginProps = function pushMarginProps(_ref4) {
  var direction = _ref4.direction,
      index = _ref4.index,
      gutterWidth = _ref4.gutterWidth,
      props = _ref4.props,
      theme = _ref4.theme,
      restProps = _objectWithoutProperties(_ref4, ['direction', 'index', 'gutterWidth', 'props', 'theme']);

  var flip = direction === 'row-reverse';
  props.marginEnd.push(getMarginOrGutter(_extends({}, restProps, {
    gutterWidth: flip ? 0 : gutterWidth,
    index: index,
    theme: theme
  })));
  props.marginStart.push(getMarginOrGutter(_extends({}, restProps, {
    gutterWidth: flip ? gutterWidth : 0,
    index: index,
    start: true,
    theme: theme
  })));
};

var styles = {
  root: function root(_ref5) {
    var breakpoints = _ref5.breakpoints,
        alignItems = _ref5.alignItems,
        direction = _ref5.direction,
        inline = _ref5.inline,
        justifyContent = _ref5.justifyContent,
        theme = _ref5.theme,
        wrap = _ref5.wrap;

    var mapValueToProperty = function mapValueToProperty(property, value) {
      var map = {
        alignItems: getAlignment,
        display: function display(value) {
          return value === undefined || value === false ? 'flex' : 'inline-flex';
        },
        flexDirection: function flexDirection(value) {
          return value;
        },
        flexWrap: function flexWrap(value) {
          return value ? 'wrap' : value === false ? 'nowrap' : value;
        },
        justifyContent: getJustification
      };

      return map[property](value);
    };

    return getResponsiveStyles({
      breakpoints: breakpoints,
      mapValueToProperty: mapValueToProperty,
      styles: {
        alignItems: alignItems,
        display: inline,
        flexDirection: direction,
        flexWrap: wrap,
        justifyContent: justifyContent
      },
      theme: theme
    });
  }
};

var Root = createStyledComponent(Box, styles.root, {
  displayName: 'Flex',
  filterProps: ['inline']
});

var ThemedRoot = withTheme(function (_ref6) {
  var breakpoints = _ref6.breakpoints,
      children = _ref6.children,
      direction = _ref6.direction,
      gutterWidth = _ref6.gutterWidth,
      theme = _ref6.theme,
      restProps = _objectWithoutProperties(_ref6, ['breakpoints', 'children', 'direction', 'gutterWidth', 'theme']);

  var rootProps = _extends({
    breakpoints: breakpoints,
    direction: direction,
    gutterWidth: gutterWidth
  }, restProps);

  var flexItems = void 0;
  flexItems = Children.map(children, function (child, index) {
    if (child && child.props) {
      var _child$props = child.props,
          propBreakpoints = _child$props.breakpoints,
          restChildProps = _objectWithoutProperties(_child$props, ['breakpoints']);

      var props = {
        breakpoints: propBreakpoints || breakpoints
      };

      var flexItemsCount = Children.count(children);
      if (gutterWidth && index < flexItemsCount - 1) {
        props = _extends({}, props, getMarginProps(_extends({
          direction: direction,
          gutterWidth: gutterWidth,
          theme: theme
        }, restChildProps)));
      }
      return cloneElement(child, props);
    }
    return child;
  });

  return React.createElement(
    Root,
    rootProps,
    flexItems
  );
});

/**
 * Flex component is used together with [FlexItem](/components/flex-item) to lay out
 * other components in a flexible, and optionally responsive, manner.
 */
var Flex = function Flex(props) {
  return React.createElement(ThemedRoot, props);
};

Flex.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Align items along the cross axis [[Responsive-capable]](#responsive) */
  alignItems: PropTypes.oneOfType([PropTypes.oneOf(['start']), PropTypes.oneOf(['end']), PropTypes.oneOf(['center']), PropTypes.oneOf(['stretch']), PropTypes.arrayOf(PropTypes.oneOf(['start', 'end', 'center', 'stretch']))]),

  /**
   * Media query (min-width) breakpoints along which to apply props marked
   * "&#xfeff;[[Responsive-capable]](#responsive)&#xfeff;"
   */
  breakpoints: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired),

  /** Must be [FlexItem(s)](./flex-item). */
  children: function children() {
    return (typeof React$Node === 'function' ? PropTypes.instanceOf(React$Node).isRequired : PropTypes.any.isRequired).apply(this, arguments);
  },

  /**
   * Direction of flow of items along the main axis
   * [[Responsive-capable]](#responsive)
   */
  direction: PropTypes.oneOfType([PropTypes.oneOf(['column']), PropTypes.oneOf(['column-reverse']), PropTypes.oneOf(['row']), PropTypes.oneOf(['row-reverse']), PropTypes.arrayOf(PropTypes.oneOf(['column', 'column-reverse', 'row', 'row-reverse']))]),

  /** Size of gap between children */
  gutterWidth: PropTypes.oneOfType([PropTypes.oneOf(['xxs']), PropTypes.oneOf(['xs']), PropTypes.oneOf(['sm']), PropTypes.oneOf(['md']), PropTypes.oneOf(['lg']), PropTypes.oneOf(['xl']), PropTypes.oneOf(['xxl']), PropTypes.number, PropTypes.string]),

  /** Align items along the main axis [[Responsive-capable]](#responsive) */
  justifyContent: PropTypes.oneOfType([PropTypes.oneOf(['start']), PropTypes.oneOf(['end']), PropTypes.oneOf(['center']), PropTypes.oneOf(['around']), PropTypes.oneOf(['between']), PropTypes.oneOf(['evenly']), PropTypes.arrayOf(PropTypes.oneOf(['start', 'end', 'center', 'around', 'between', 'evenly']))]),

  /**
   * Determines if items can wrap along main axis
   * [[Responsive-capable]](#responsive)
   */
  wrap: PropTypes.oneOfType([PropTypes.bool, PropTypes.arrayOf(PropTypes.bool)])
} : {};
Flex.defaultProps = {
  alignItems: 'stretch',
  direction: 'row',
  gutterWidth: 'md',
  justifyContent: 'start'
};

export default Flex;
import PropTypes from 'prop-types';