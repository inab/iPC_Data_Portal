var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Children, cloneElement, Component } from 'react';
import { canUseDOM } from 'exenv';
import { createStyledComponent } from '../styles';
import { withTheme } from '../themes';
import { generateId } from '../utils';
import TabList from './TabList';
import TabPanel from './TabPanel';

var Root = createStyledComponent('div', function (_ref) {
  var height = _ref.height,
      position = _ref.position;

  var flexDirection = {
    bottom: 'column-reverse',
    end: 'row-reverse',
    start: 'row',
    top: 'column'
  };

  return {
    display: 'flex',
    flexDirection: flexDirection[position],
    height: height
  };
}, {
  displayName: 'Tabs',
  includeStyleReset: true
});

/**
 * Tabs provide easy management for viewing related content in the same layout
 * region.
 */

var Tabs = function (_Component) {
  _inherits(Tabs, _Component);

  function Tabs() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, Tabs);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call.apply(_ref2, [this].concat(args))), _this), _this.state = {
      selectedTabIndex: _this.props.defaultSelectedTabIndex || 0
    }, _this.disabledTabIndexes = new Set(), _this.id = _this.props.id || 'tabs-' + generateId(), _this.vertical = _this.props.position === 'start' || _this.props.position === 'end', _this.getPanelId = function (index) {
      return _this.id + '-panel-' + index;
    }, _this.getTabId = function (index) {
      return _this.id + '-tab-' + index;
    }, _this.setRootRef = function (node) {
      _this.root = node;
    }, _this.handleClick = function (event) {
      event.preventDefault();
      event.persist();
      var target = event.currentTarget;

      var selectedTabIndex = parseInt(target.getAttribute('data-index'));

      if (_this.isControlled('selectedTabIndex') && selectedTabIndex !== _this.props.selectedTabIndex) {
        _this.changeActions(selectedTabIndex, event);
      } else {
        _this.setSelectedTabIndex(selectedTabIndex, event);
      }
    }, _this.handleKeyDown = function (event) {
      event.persist();
      if (['ArrowLeft', 'ArrowRight'].indexOf(event.key) !== -1) {
        event.preventDefault();
        var rtl = _this.props.theme.direction === 'rtl';
        var flippedDirections = {
          ArrowLeft: 'ArrowRight',
          ArrowRight: 'ArrowLeft'
        };
        var key = rtl && flippedDirections[event.key] ? flippedDirections[event.key] : event.key;
        _this.handleIncrement(key, event);
      } else if (_this.vertical && ['ArrowDown', 'ArrowUp'].indexOf(event.key) !== -1) {
        event.preventDefault();
        _this.handleIncrement(event.key, event);
      }
    }, _this.handleIncrement = function (direction, event) {
      var selectedTabIndex = _this.getControllableValue('selectedTabIndex');
      var nextIndex = direction === 'ArrowRight' || direction === 'ArrowDown' ? selectedTabIndex === _this.lastIndex ? 0 : _this.getNonDisabledIndex(selectedTabIndex + 1) : selectedTabIndex === 0 ? _this.lastIndex : _this.getNonDisabledIndex(selectedTabIndex - 1, { decrease: true });
      _this.setSelectedTabIndex(nextIndex, event);
    }, _this.getNonDisabledIndex = function (index) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          decrease = _ref3.decrease;

      return _this.disabledTabIndexes.has(index) ? _this.getNonDisabledIndex(decrease ? index - 1 : index + 1, { decrease: decrease }) : index;
    }, _this.setSelectedTabIndex = function (selectedTabIndex, event) {
      if (selectedTabIndex !== _this.state.selectedTabIndex) {
        _this.setState({
          selectedTabIndex: selectedTabIndex
        }, function () {
          if (canUseDOM) {
            var nextTab = _this.root && _this.root.querySelector('[data-index="' + selectedTabIndex + '"]');
            nextTab && nextTab.focus();
          }
          _this.changeActions(selectedTabIndex, event);
        });
      }
    }, _this.changeActions = function (selectedTabIndex, event) {
      var onChange = _this.props.onChange;

      onChange && onChange(selectedTabIndex, event);
    }, _this.isControlled = function (prop) {
      return _this.props.hasOwnProperty(prop);
    }, _this.getControllableValue = function (key) {
      return _this.isControlled(key) ? _this.props[key] : _this.state[key];
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Tabs, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          align = _props.align,
          children = _props.children,
          label = _props.label,
          height = _props.height,
          maxTabWidth = _props.maxTabWidth,
          position = _props.position,
          restProps = _objectWithoutProperties(_props, ['align', 'children', 'label', 'height', 'maxTabWidth', 'position']);

      var selectedTabIndex = this.getControllableValue('selectedTabIndex');

      var ids = [];
      var tabPanelProps = void 0;
      var tabItems = [];

      Children.forEach(children, function (tab, index) {
        var _tab$props = tab.props,
            children = _tab$props.children,
            disabled = _tab$props.disabled,
            icon = _tab$props.icon,
            id = _tab$props.id,
            maxWidth = _tab$props.maxWidth,
            title = _tab$props.title;

        if (id && ids.indexOf(id) === -1) {
          ids.push(id);
        } else if (id) {
          throw new Error('[mineral-ui/Tabs] Tab id ' + id + ' is not unique');
        }
        var panelId = _this2.getPanelId(index);
        var selected = index === selectedTabIndex;
        var tabId = id || _this2.getTabId(index);
        var tabProps = {
          children: title,
          disabled: disabled,
          icon: icon,
          id: tabId,
          index: index,
          key: index,
          maxWidth: !_this2.vertical && align === 'justify' ? undefined : maxWidth || maxTabWidth,
          onClick: !disabled ? _this2.handleClick : function (event) {
            event.preventDefault();
          },
          onKeyDown: _this2.handleKeyDown,
          panelId: panelId,
          position: position,
          selected: selected
        };
        tabItems.push(cloneElement(tab, tabProps));

        if (selected) {
          tabPanelProps = {
            children: children,
            id: panelId,
            position: position,
            tabId: tabId
          };
        }

        if (disabled) {
          _this2.disabledTabIndexes.add(index);
        } else {
          _this2.lastIndex = index;
        }
      });

      var rootProps = _extends({
        innerRef: this.setRootRef,
        height: height,
        position: position
      }, restProps, {
        'aria-labelledby': undefined
      });

      var tabListProps = {
        align: align,
        'aria-label': label,
        'aria-labelledby': this.props['aria-labelledby'],
        height: height,
        onIncrement: this.handleIncrement,
        position: position,
        role: 'tablist',
        vertical: this.vertical
      };

      return React.createElement(
        Root,
        rootProps,
        React.createElement(
          TabList,
          tabListProps,
          tabItems
        ),
        React.createElement(TabPanel, tabPanelProps)
      );
    }
  }]);

  return Tabs;
}(Component);

Tabs.defaultProps = {
  align: 'start',
  maxTabWidth: '8.5em',
  position: 'top'
};
Tabs.propTypes = process.env.NODE_ENV !== "production" ? {
  /**  Horizontal or vertical alignment of Tabs in the tab list */
  align: PropTypes.oneOf(['start', 'center', 'end', 'justify']),

  /** @Private */
  "aria-labelledby": PropTypes.string,

  /** Content of Tabs; must be Tab components */
  children: function children() {
    return (typeof React$Node === 'function' ? PropTypes.instanceOf(React$Node) : PropTypes.any).apply(this, arguments);
  },

  /**
   * Index of the selected Tab; primarily for use with uncontrolled components
   */
  defaultSelectedTabIndex: PropTypes.number,

  /** Id of Tabs */
  id: PropTypes.string,

  /** Accessible label for Tabs */
  label: PropTypes.string.isRequired,

  /** Height of Tabs */
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /** Maximum width of each Tab */
  maxTabWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /** Called when a Tab is selected */
  onChange: PropTypes.func,

  /** Position of the tab list in relation to the tab panel */
  position: PropTypes.oneOf(['bottom', 'end', 'start', 'top']),

  /**
   * Index of the selected Tab; primarily for use with controlled components.
   * If this prop is specified, an `onChange` handler must also be specified.
   * See also: `defaultSelectedTabIndex`
   */
  selectedTabIndex: PropTypes.number,

  /** @Private Theme */
  theme: PropTypes.object.isRequired
} : {};


export default withTheme(Tabs);
import PropTypes from 'prop-types';