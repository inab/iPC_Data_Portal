var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jsx = function () { var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; return function createRawReactElement(type, props, key, children) { var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = {}; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { cloneElement, Component } from 'react';
import { canUseDOM } from 'exenv';
import FocusTrap from 'focus-trap-react';
import noScroll from 'no-scroll';
import Transition from 'react-transition-group/Transition';
import { createStyledComponent, pxToEm } from '../styles';
import { createThemedComponent, withTheme } from '../themes';
import { generateId } from '../utils';
import { excludeByType, findByType } from '../utils/children';
import Button from '../Button';
import IconClose from '../Icon/IconClose';
import Portal from '../Portal';
import EventListener from '../EventListener';
import DialogActions from './DialogActions';
import DialogBody from './DialogBody';
import DialogFooter from './DialogFooter';
import DialogHeader from './DialogHeader';
import DialogTitle from './DialogTitle';
import { componentTheme as dialogRowComponentTheme } from './DialogRow';

export var componentTheme = function componentTheme(baseTheme) {
  return _extends({
    Dialog_transitionDuration: '250ms',
    Dialog_zIndex: baseTheme.zIndex_1600,

    DialogCloseButton_margin: baseTheme.space_inline_sm,

    DialogContent_backgroundColor: baseTheme.panel_backgroundColor,
    DialogContent_borderColor: baseTheme.panel_borderColor,
    DialogContent_borderRadius: baseTheme.borderRadius_1,
    DialogContent_boxShadow: baseTheme.boxShadow_5,
    DialogContent_maxHeight: '80vh',
    DialogContent_maxHeight_small: pxToEm(560),
    DialogContent_maxHeight_medium: pxToEm(560),
    DialogContent_maxHeight_large: pxToEm(720),
    DialogContent_maxWidth_small: pxToEm(400),
    DialogContent_maxWidth_medium: pxToEm(640),
    DialogContent_maxWidth_large: pxToEm(1200),
    DialogContent_minWidth: pxToEm(360),
    DialogContent_offsetVertical: baseTheme.space_stack_xxl,
    DialogContent_width_small: '35vw',
    DialogContent_width_medium: '50vw',
    DialogContent_width_large: '80vw',

    DialogOverlay_backgroundColor: 'rgba(0, 0, 0, 0.6)'

  }, dialogRowComponentTheme(baseTheme), baseTheme);
};

var styles = {
  animate: function animate(_ref) {
    var state = _ref.state,
        baseTheme = _ref.theme;

    var theme = componentTheme(baseTheme);
    return {
      opacity: state === 'entered' ? 1 : 0,
      position: 'relative',
      transition: 'opacity ' + theme.Dialog_transitionDuration + ' ease',
      willChange: 'opacity',
      zIndex: theme.Dialog_zIndex
    };
  },
  content: function content(_ref2) {
    var size = _ref2.size,
        baseTheme = _ref2.theme;

    var theme = componentTheme(baseTheme);

    var getSizeStyles = function getSizeStyles(size) {
      var maxWidth = theme['DialogContent_maxWidth_' + size];
      var maxHeight = theme['DialogContent_maxHeight_' + size];
      var width = theme['DialogContent_width_' + size];
      var offsetVertical = theme.DialogContent_offsetVertical;

      var maxHeightNumber = parseFloat(maxHeight);
      var offsetVerticalNumber = parseFloat(offsetVertical);
      var minHeight = maxHeightNumber + 2 * offsetVerticalNumber + 'em';

      return _defineProperty({
        maxWidth: maxWidth,
        width: width

      }, '@media(min-height: ' + minHeight + ')', {
        maxHeight: maxHeight
      });
    };

    return _extends({
      backgroundColor: theme.DialogContent_backgroundColor,
      border: '1px solid ' + theme.DialogContent_borderColor,
      borderRadius: theme.DialogContent_borderRadius,
      boxShadow: theme.DialogContent_boxShadow,
      display: 'flex',
      flexDirection: 'column',
      maxHeight: theme.DialogContent_maxHeight,
      minWidth: theme.DialogContent_minWidth,
      pointerEvents: 'all',
      position: 'relative'
    }, getSizeStyles(size));
  },
  ieWrapper: {
    display: 'flex'
  },
  overlay: function overlay(_ref4) {
    var baseTheme = _ref4.theme;

    var theme = componentTheme(baseTheme);

    return {
      backgroundColor: theme.DialogOverlay_backgroundColor,
      bottom: 0,
      left: 0,
      overflow: 'hidden',
      position: 'absolute',
      right: 0,
      top: 0
    };
  },
  root: function root(_ref5) {
    var modeless = _ref5.modeless;
    return {
      alignItems: 'center',
      bottom: 0,
      display: 'flex',
      justifyContent: 'center',
      left: 0,
      position: 'fixed',
      pointerEvents: modeless ? 'none' : undefined,
      right: 0,
      top: 0
    };
  }
};

var Root = createStyledComponent('div', styles.root, {
  displayName: 'Dialog',
  filterProps: ['title'],
  includeStyleReset: true
});

var Overlay = createStyledComponent('div', styles.overlay, {
  displayName: 'Overlay'
});

var IEWrapper = createStyledComponent('div', styles.ieWrapper);

var Content = createStyledComponent('div', styles.content, {
  displayName: 'DialogContent'
});

var Animate = createStyledComponent('div', styles.animate, {
  displayName: 'Animate'
});

var Animation = withTheme(function (_ref6) {
  var children = _ref6.children,
      theme = _ref6.theme,
      restProps = _objectWithoutProperties(_ref6, ['children', 'theme']);

  return React.createElement(
    Transition,
    _extends({
      appear: true,
      mountOnEnter: true,
      timeout: parseFloat(componentTheme(theme).Dialog_transitionDuration),
      unmountOnExit: true
    }, restProps),
    function (state) {
      return _jsx(Animate, {
        state: state
      }, void 0, children);
    }
  );
});

var ThemedButton = createThemedComponent(Button, function (_ref7) {
  var theme = _ref7.theme;
  return {
    ButtonIcon_color: theme.color
  };
});

var CloseButton = createStyledComponent(ThemedButton, function (_ref8) {
  var baseTheme = _ref8.theme;

  var theme = componentTheme(baseTheme);
  var marginProperty = theme.direction === 'rtl' ? 'marginRight' : 'marginLeft';

  return _defineProperty({}, marginProperty, theme.DialogCloseButton_margin);
}, {
  displayName: 'CloseButton',
  withProps: {
    iconStart: _jsx(IconClose, {}),
    minimal: true,
    size: 'small'
  }
});

/**
 * Dialog displays content in a layer above the app and requires user
 * interaction to dismiss it. It may appear contextually or as a modal.
 */

var _ref12 = _jsx(Overlay, {});

var Dialog = function (_Component) {
  _inherits(Dialog, _Component);

  function Dialog() {
    var _ref10;

    var _temp, _this, _ret;

    _classCallCheck(this, Dialog);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref10 = Dialog.__proto__ || Object.getPrototypeOf(Dialog)).call.apply(_ref10, [this].concat(args))), _this), _this.state = {
      isExited: false,
      isExiting: false
    }, _this.id = _this.props.id || 'dialog-' + generateId(), _this.renderHeader = function () {
      var _this$props = _this.props,
          children = _this$props.children,
          closeButtonLabel = _this$props.closeButtonLabel,
          preventCloseButtonClose = _this$props.preventCloseButtonClose,
          showCloseButton = _this$props.showCloseButton,
          title = _this$props.title,
          variant = _this$props.variant;


      var closeButtonProps = _extends({
        'aria-label': closeButtonLabel
      }, preventCloseButtonClose ? undefined : { onClick: _this.close });

      // prettier-ignore
      var closeButton = showCloseButton ? React.createElement(CloseButton, closeButtonProps) : undefined;

      var header = void 0;
      var titleProps = {
        id: _this.getTitleId(),
        variant: variant
      };

      if (title) {
        header = _jsx(DialogHeader, {
          closeButton: closeButton
        }, void 0, typeof title === 'string' ? React.createElement(
          DialogTitle,
          titleProps,
          title
        ) : cloneElement(title, titleProps));
      } else {
        var headerChild = findByType(children, DialogHeader);
        if (headerChild) {
          var headerChildProps = {
            titleProps: titleProps,
            closeButton: headerChild.props.closeButton || closeButton
          };
          header = cloneElement(headerChild, headerChildProps);
        }
      }

      return header;
    }, _this.renderBody = function () {
      var children = _this.props.children;


      var body = void 0;
      var bodyChild = findByType(children, DialogBody);
      if (bodyChild) {
        body = bodyChild;
      } else {
        var bodyChildren = excludeByType(children, [DialogHeader, DialogFooter]);
        if (bodyChildren) {
          body = _jsx(DialogBody, {}, void 0, bodyChildren);
        }
      }

      return body;
    }, _this.renderFooter = function () {
      var _this$props2 = _this.props,
          actions = _this$props2.actions,
          children = _this$props2.children,
          size = _this$props2.size,
          variant = _this$props2.variant;


      var footer = void 0;
      if (actions) {
        var keyedActions = actions.map(function (_ref11, index) {
          var text = _ref11.text,
              buttonSize = _ref11.size,
              restProps = _objectWithoutProperties(_ref11, ['text', 'size']);

          var buttonProps = _extends({
            size: buttonSize || (size === 'large' ? 'large' : 'medium')
          }, restProps);
          return React.createElement(
            Button,
            _extends({}, buttonProps, { key: index }),
            text
          );
        });
        footer = _jsx(DialogFooter, {}, void 0, _jsx(DialogActions, {
          variant: variant
        }, void 0, keyedActions));
      } else {
        var footerChild = findByType(children, DialogFooter);
        if (footerChild) {
          footer = footerChild;
        }
      }

      return footer;
    }, _this.getTitleId = function () {
      return _this.id + '-title';
    }, _this.getContentId = function () {
      return _this.id + '-content';
    }, _this.setContentRef = function (node) {
      _this.dialogContent = node;
    }, _this.setRootRef = function (node) {
      _this.dialogRoot = node;
    }, _this.setLastFocusedElement = function () {
      if (canUseDOM) {
        var _global$document = global.document,
            activeElement = _global$document.activeElement,
            body = _global$document.body;

        _this.lastFocusedElement = activeElement && activeElement.focus ? activeElement : body;
      }
    }, _this.restoreFocus = function () {
      _this.lastFocusedElement && _this.lastFocusedElement.focus();
    }, _this.setInitialFocus = function () {
      _this.dialogRoot && _this.dialogRoot.focus();
    }, _this.open = function () {
      var modeless = _this.props.modeless;


      _this.setLastFocusedElement();

      if (!modeless) {
        _this.setAppNode();
        _this.disableAppNode();
        if (canUseDOM) {
          noScroll.on();
        }
      }

      _this.setState({
        isExited: false
      });
    }, _this.close = function () {
      _this.handleExiting();
    }, _this.handleClick = function (event) {
      if (_this.isEventOutsideNode(event, _this.dialogContent)) {
        _this.close();
      }
    }, _this.handleDocumentKeydown = function (event) {
      if (event.key === 'Escape' && !event.defaultPrevented) {
        _this.close();
      }
    }, _this.handleEntered = function () {
      !_this.props.disableFocusOnOpen && _this.setInitialFocus();
      _this.props.onOpen && _this.props.onOpen();
    }, _this.handleExiting = function () {
      _this.setState({
        isExiting: true
      });
    }, _this.handleExited = function () {
      var _this$props3 = _this.props,
          modeless = _this$props3.modeless,
          onClose = _this$props3.onClose;


      _this.setState({
        isExited: true,
        isExiting: false
      }, function () {
        if (!modeless) {
          if (canUseDOM) {
            noScroll.off();
          }
          _this.enableAppNode();
        }

        _this.restoreFocus();
        onClose && onClose();
      });
    }, _this.isEventOutsideNode = function (event, node) {
      var target = event.target;

      return node && target instanceof Node && !node.contains(target);
    }, _this.setAppNode = function () {
      var appSelector = _this.props.appSelector;


      if (appSelector && canUseDOM) {
        _this.appNodes = Array.from(document.querySelectorAll(appSelector));

        if (!_this.appNodes.length) {
          throw new Error('[mineral-ui/Dialog]: Unable to find app node(s) using the appSelector of \'' + appSelector + '\'.');
        }
      }
    }, _this.disableAppNode = function () {
      _this.appNodes && _this.appNodes.forEach(function (node) {
        return node.setAttribute('aria-hidden', 'true');
      });
    }, _this.enableAppNode = function () {
      _this.appNodes && _this.appNodes.forEach(function (node) {
        return node.removeAttribute('aria-hidden');
      });
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Dialog, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (!prevProps.isOpen && this.props.isOpen) {
        this.open();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          closeOnClickOutside = _props.closeOnClickOutside,
          closeOnEscape = _props.closeOnEscape,
          disableFocusTrap = _props.disableFocusTrap,
          isOpen = _props.isOpen,
          hideOverlay = _props.hideOverlay,
          modeless = _props.modeless,
          size = _props.size,
          title = _props.title,
          usePortal = _props.usePortal,
          restProps = _objectWithoutProperties(_props, ['children', 'closeOnClickOutside', 'closeOnEscape', 'disableFocusTrap', 'isOpen', 'hideOverlay', 'modeless', 'size', 'title', 'usePortal']);

      var _state = this.state,
          isExited = _state.isExited,
          isExiting = _state.isExiting;


      if (isExited) {
        return null;
      }

      var headerId = this.getTitleId();
      var contentId = this.getContentId();
      var hasBody = findByType(children, DialogBody);
      var hasImmediatleTitle = findByType(children, DialogTitle);
      var hasHeader = title || findByType(children, DialogHeader);

      if (hasBody && hasImmediatleTitle) {
        throw new Error('[mineral-ui/Dialog] You must wrap DialogTitle in DialogHeader');
      }
      if (!hasHeader && !this.props['aria-label']) {
        throw new Error('[mineral-ui/Dialog] You must provide an accessible title via the title prop, the DialogTitle component, or the aria-label prop');
      }

      var rootProps = _extends({
        'aria-labelledby': this.props['aria-label'] ? undefined : hasHeader ? headerId : contentId,
        'aria-modal': !modeless,
        id: this.id,
        innerRef: this.setRootRef,
        modeless: modeless,
        role: 'dialog',
        tabIndex: '-1'
      }, closeOnClickOutside && !modeless ? { onClick: this.handleClick } : undefined, restProps);

      var contentProps = {
        id: contentId,
        innerRef: this.setContentRef,
        role: 'document',
        size: size
      };

      var animationProps = {
        in: isOpen && !isExiting,
        onExiting: this.handleExiting,
        onExited: this.handleExited,
        onEntered: this.handleEntered
      };

      var focusTrapProps = {
        active: !disableFocusTrap && !modeless
      };

      var output = React.createElement(
        Animation,
        animationProps,
        React.createElement(
          FocusTrap,
          focusTrapProps,
          React.createElement(
            Root,
            rootProps,
            !hideOverlay && !modeless && _ref12,
            _jsx(IEWrapper, {}, void 0, React.createElement(
              Content,
              contentProps,
              this.renderHeader(),
              this.renderBody(),
              this.renderFooter()
            )),
            closeOnEscape && _jsx(EventListener, {
              listeners: [{
                target: 'document',
                event: 'keydown',
                handler: this.handleDocumentKeydown
              }]
            })
          )
        )
      );

      return usePortal ? _jsx(Portal, {}, void 0, output) : output;
    }
  }]);

  return Dialog;
}(Component);

Dialog.defaultProps = {
  closeButtonLabel: 'close',
  closeOnClickOutside: true,
  closeOnEscape: true,
  size: 'medium',
  usePortal: true
};
export default Dialog;
Dialog.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * Configuration for the [Buttons](/components/button) rendered at the bottom
   * of Dialog; accepts all Button props
   */
  actions: PropTypes.arrayOf(PropTypes.shape({
    text: PropTypes.string.isRequired,
    size: PropTypes.oneOf(['small', 'medium', 'large', 'jumbo'])
  }).isRequired),

  /**
   * CSS selector matching the node(s) which will be accessibly hidden (unless
   * \`modeless\`)
   */
  appSelector: PropTypes.string,

  /** @Private Accessible label */
  "aria-label": PropTypes.string,

  /**
   * Content of Dialog (see the [Basic](#basic) and
   * [Alternate Syntax](#alternate) examples)
   */
  children: function children() {
    return (typeof React$Node === 'function' ? PropTypes.instanceOf(React$Node) : PropTypes.any).apply(this, arguments);
  },

  /** Accessible label for the close button */
  closeButtonLabel: PropTypes.string,

  /** Close Dialog with the 'Escape' key */
  closeOnEscape: PropTypes.bool,

  /** Close Dialog by clicking outside of its content */
  closeOnClickOutside: PropTypes.bool,

  /** Disable focus being placed on Dialog upon opening */
  disableFocusOnOpen: PropTypes.bool,

  /** Disable focus being trapped within the Dialog when open */
  disableFocusTrap: PropTypes.bool,

  /** Hide the overlay underneath Dialog */
  hideOverlay: PropTypes.bool,

  /** Id of the Dialog */
  id: PropTypes.string,

  /** Dialog only renders its content when true */
  isOpen: PropTypes.bool,

  /** Renders Dialog without modal behavior ([see example](#modeless)) */
  modeless: PropTypes.bool,

  /** Called when Dialog is closed */
  onClose: PropTypes.func,

  /** Called when Dialog is opened */
  onOpen: PropTypes.func,

  /** @Private Prevent the dialog from closing when the close button is clicked */
  preventCloseButtonClose: PropTypes.bool,

  /** Render a close button for Dialog */
  showCloseButton: PropTypes.bool,

  /** Available sizes */
  size: PropTypes.oneOf(['small', 'medium', 'large']),

  /**
   * Title of the dialog; must be a string or
   * [DialogTitle](/components/dialog-title)
   */
  title: PropTypes.oneOfType([PropTypes.string, function () {
    return (typeof React$Element === 'function' ? PropTypes.instanceOf(React$Element) : PropTypes.any).apply(this, arguments);
  }]),

  /** @Private Use a Portal to render Dialog to the body */
  usePortal: PropTypes.bool,

  /** Available variants */
  variant: PropTypes.oneOf(['danger', 'success', 'warning'])
} : {};
import PropTypes from 'prop-types';