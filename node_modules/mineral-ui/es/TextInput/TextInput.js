var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

import React from 'react';
import { createStyledComponent, getNormalizedValue } from '../styles';
import { createThemedComponent, mapComponentThemes } from '../themes';
import FauxControl, { componentTheme as fauxControlComponentTheme } from '../FauxControl/FauxControl';

export var componentTheme = function componentTheme(baseTheme) {
  return mapComponentThemes({
    name: 'FauxControl',
    theme: fauxControlComponentTheme(baseTheme)
  }, {
    name: 'TextInput',
    theme: {
      TextInput_height_small: baseTheme.size_small,
      TextInput_height_medium: baseTheme.size_medium,
      TextInput_height_large: baseTheme.size_large,
      TextInput_height_jumbo: baseTheme.size_jumbo,

      TextInputIcon_color: baseTheme.color_gray_40
    }
  }, baseTheme);
};

var ThemedFauxControl = createThemedComponent(FauxControl, function (_ref) {
  var baseTheme = _ref.theme;
  return mapComponentThemes({
    name: 'TextInput',
    theme: componentTheme(baseTheme)
  }, {
    name: 'FauxControl',
    theme: {}
  }, baseTheme);
});

var styles = {
  input: function input(_ref2) {
    var controlSize = _ref2.controlSize,
        nonHtmlSize = _ref2.size,
        baseTheme = _ref2.theme;

    var theme = componentTheme(baseTheme);

    var size = controlSize || nonHtmlSize;
    var fontSize = size === 'small' ? theme.TextInput_fontSize_small : theme.TextInput_fontSize;

    return {
      backgroundColor: 'transparent',
      border: 0,
      boxShadow: 'none',
      flex: '1 1 auto',
      fontFamily: 'inherit',
      height: getNormalizedValue(theme['TextInput_height_' + size], fontSize),
      minWidth: 0,
      width: '100%',

      // Normalize Safari search inputs
      '&[type="search"]': {
        WebkitAppearance: 'none',

        '&::-webkit-search-decoration': {
          WebkitAppearance: 'none'
        }
      }
    };
  },
  root: function root(_ref3) {
    var baseTheme = _ref3.theme,
        variant = _ref3.variant;

    var theme = componentTheme(baseTheme);

    if (variant) {
      theme = _extends({}, theme, {
        TextInputIcon_color: theme['icon_color_' + variant]
      });
    }

    return {
      alignItems: 'center',
      cursor: 'text',
      display: 'flex',
      width: '100%',

      '& [role="img"]': {
        color: theme.TextInputIcon_color,
        display: 'block',
        flex: '0 0 auto',
        margin: '0 ' + theme.TextInputIcon_marginHorizontal,

        '&:last-of-type': {
          color: theme.TextInputIcon_color
        }
      }
    };
  }
};

var Root = createStyledComponent(ThemedFauxControl, styles.root, {
  displayName: 'TextInput'
});
var Input = createStyledComponent('input', styles.input, {
  displayName: 'Input',
  rootEl: 'input',
  forwardProps: ['size']
});

/**
 * TextInput allows your app to accept a text value from the user. It supports
 * any of the text-based input types, such as `text`, `number` or `email`.
 */
var TextInput = function TextInput(props) {
  var className = props.className,
      disabled = props.disabled,
      iconEnd = props.iconEnd,
      iconStart = props.iconStart,
      inputRef = props.inputRef,
      invalid = props.invalid,
      prefix = props.prefix,
      readOnly = props.readOnly,
      required = props.required,
      otherRootProps = props.rootProps,
      size = props.size,
      suffix = props.suffix,
      variant = props.variant,
      restProps = _objectWithoutProperties(props, ['className', 'disabled', 'iconEnd', 'iconStart', 'inputRef', 'invalid', 'prefix', 'readOnly', 'required', 'rootProps', 'size', 'suffix', 'variant']);

  var inputProps = _extends({
    'aria-invalid': invalid,
    'aria-required': required,
    controlRef: inputRef,
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }, restProps);

  var rootProps = _extends({
    className: className,
    control: Input,
    controlProps: inputProps,
    disabled: disabled,
    iconEnd: iconEnd,
    iconStart: iconStart,
    prefix: prefix,
    readOnly: readOnly,
    size: size,
    suffix: suffix,
    variant: variant
  }, otherRootProps);

  return React.createElement(Root, rootProps);
};

TextInput.propTypes = process.env.NODE_ENV !== "production" ? {
  /** @Private CSS className */
  className: PropTypes.string,

  /** Initial value of the input. Primarily for use with uncontrolled components */
  defaultValue: PropTypes.string,

  /** Disables the input */
  disabled: PropTypes.bool,

  /** HTML `size` attribute */
  htmlSize: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /** Icon located at the start of the input */
  iconStart: function iconStart() {
    return (typeof React$Element === 'function' ? PropTypes.instanceOf(React$Element) : PropTypes.any).apply(this, arguments);
  },

  /** Icon located at the end of the input */
  iconEnd: function iconEnd() {
    return (typeof React$Element === 'function' ? PropTypes.instanceOf(React$Element) : PropTypes.any).apply(this, arguments);
  },

  /** ref for the input */
  inputRef: PropTypes.func,

  /** Props to be applied directly to the root element, rather than the input */
  rootProps: PropTypes.object,

  /** Indicates that the value of the element is invalid */
  invalid: PropTypes.bool,

  /** Function called when input value changes */
  onChange: PropTypes.func,

  /** Text to display before input value */
  prefix: PropTypes.oneOfType([PropTypes.string, function () {
    return (typeof React$Element === 'function' ? PropTypes.instanceOf(React$Element) : PropTypes.any).apply(this, arguments);
  }]),

  /** Indicates that the user cannot modify the value of the input */
  readOnly: PropTypes.bool,

  /** Indicates that the user must fill in a value before submitting a form */
  required: PropTypes.bool,

  /** Available sizes */
  size: PropTypes.oneOf(['small', 'medium', 'large', 'jumbo']),

  /** Text to display after input value */
  suffix: PropTypes.oneOfType([PropTypes.string, function () {
    return (typeof React$Element === 'function' ? PropTypes.instanceOf(React$Element) : PropTypes.any).apply(this, arguments);
  }]),

  /** Type of input. Not all types are equally supported across browsers. */
  type: PropTypes.oneOf(['date', 'datetime-local', 'email', 'month', 'number', 'password', 'search', 'tel', 'text', 'time', 'url', 'week']),

  /**
   * The initial value of the input. Primarily for use with controlled
   * components.  If this prop is specified, an onChange handler must also be
   * specified.  Also see `defaultValue`.
   */
  value: PropTypes.string,

  /** Available variants */
  variant: PropTypes.oneOf(['success', 'warning', 'danger'])
} : {};
TextInput.defaultProps = {
  size: 'large',
  type: 'text'
};

export default TextInput;
import PropTypes from 'prop-types';