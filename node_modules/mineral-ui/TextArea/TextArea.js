'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.componentTheme = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _exenv = require('exenv');

var _fontfaceobserver = require('fontfaceobserver');

var _fontfaceobserver2 = _interopRequireDefault(_fontfaceobserver);

var _styles = require('../styles');

var _themes = require('../themes');

var _FauxControl = require('../FauxControl/FauxControl');

var _FauxControl2 = _interopRequireDefault(_FauxControl);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var componentTheme = exports.componentTheme = function componentTheme(baseTheme) {
  return (0, _themes.mapComponentThemes)({
    name: 'FauxControl',
    theme: (0, _FauxControl.componentTheme)(baseTheme)
  }, {
    name: 'TextArea',
    theme: {
      // The following padding values make appearances equivalent to TextInputs of same size when rows=1.
      // This enables usage of a TextArea as a single line input that can accept multiple lines of text.
      TextArea_paddingVertical_jumbo: (0, _styles.pxToEm)(14.5),
      TextArea_paddingVertical_large: (0, _styles.pxToEm)(8.5),
      TextArea_paddingVertical_medium: (0, _styles.pxToEm)(4.5),
      TextArea_paddingVertical_small: (0, _styles.pxToEm)(2)
    }
  }, baseTheme);
};

var ThemedFauxControl = (0, _themes.createThemedComponent)(_FauxControl2.default, function (_ref) {
  var baseTheme = _ref.theme;
  return (0, _themes.mapComponentThemes)({
    name: 'TextArea',
    theme: componentTheme(baseTheme)
  }, {
    name: 'FauxControl',
    theme: {}
  }, baseTheme);
});

var styles = {
  textArea: function textArea(_ref2) {
    var resizeable = _ref2.resizeable,
        size = _ref2.size,
        baseTheme = _ref2.theme;

    var theme = componentTheme(baseTheme);

    var fontSize = size === 'small' ? theme.TextArea_fontSize_small : theme.TextArea_fontSize;
    var paddingVerticalNormalized = (0, _styles.getNormalizedValue)(theme['TextArea_paddingVertical_' + size], fontSize);

    return {
      backgroundColor: 'transparent',
      border: 0,
      boxShadow: 'none',
      flex: '1 1 auto',
      fontFamily: 'inherit',
      lineHeight: theme.lineHeight_prose,
      margin: theme.TextArea_borderWidth,
      // minHeight value is an attempt to display a single line of text.
      // It is needed when a user manually resizes a textarea.
      minHeight: parseFloat(paddingVerticalNormalized) * 2 + parseFloat(theme.TextArea_fontSize) * theme.lineHeight + parseFloat((0, _styles.pxToEm)(parseFloat(theme.TextArea_borderWidth) * 2)) + parseFloat((0, _styles.pxToEm)(2)) + 'em',
      minWidth: 0,
      outline: 0,
      paddingBottom: paddingVerticalNormalized,
      paddingTop: paddingVerticalNormalized,
      resize: resizeable ? 'vertical' : 'none',
      width: '100%'
    };
  },
  root: {
    alignItems: 'center',
    cursor: 'text',
    display: 'flex',
    width: '100%'
  }
};

var Root = (0, _styles.createStyledComponent)(ThemedFauxControl, styles.root, {
  displayName: 'TextArea'
});
var _TextArea = (0, _styles.createStyledComponent)('textarea', styles.textArea, {
  rootEl: 'textarea'
});

var sizeToRows = {
  small: 2,
  medium: 6,
  large: 8,
  jumbo: 12
};

/**
 * TextArea allows your app to accept a potentially lengthy text value from the
 * user.
 */

var TextArea = function (_Component) {
  _inherits(TextArea, _Component);

  function TextArea() {
    var _ref3;

    var _temp, _this, _ret;

    _classCallCheck(this, TextArea);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref3 = TextArea.__proto__ || Object.getPrototypeOf(TextArea)).call.apply(_ref3, [this].concat(args))), _this), _this.handleInput = function (event) {
      var _this$props = _this.props,
          autoSize = _this$props.autoSize,
          onInput = _this$props.onInput;


      autoSize && _this.autoSize();

      onInput && onInput(event);
    }, _this.autoSize = function () {
      var autoSize = _this.props.autoSize;

      if (!autoSize || !_this.textArea || !_exenv.canUseDOM) {
        return;
      }

      var _window$getComputedSt = window.getComputedStyle(_this.textArea),
          maxHeight = _window$getComputedSt.maxHeight,
          minHeight = _window$getComputedSt.minHeight;

      /** $FlowFixMe */


      _this.textArea.style.height = 'auto';
      /** $FlowFixMe */
      _this.textArea.style.overflowY = 'hidden';
      /** $FlowFixMe */
      _this.textArea.style.height = Math.max(parseFloat(minHeight), Math.min(
      /** $FlowFixMe */
      parseFloat(_this.textArea.scrollHeight), parseFloat(maxHeight) || window.Infinity)) + 'px';
    }, _this.removeAutoSize = function () {
      if (_this.textArea) {
        _this.textArea.style.height = '';
        _this.textArea.style.overflowY = '';
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(TextArea, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.autoSize();

      // Auto sized height can sometimes be slightly incorrect before web font has
      // loaded due differences in font metrics.  Here we call it again after the
      // fontFamily has loaded.
      if (this.textArea && _exenv.canUseDOM) {
        var fontFamily = window.getComputedStyle(this.textArea).fontFamily.replace(/["']/g, '').split(',')[0];
        var font = new _fontfaceobserver2.default(fontFamily);
        font.load().then(this.autoSize, function () {});
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _props = this.props,
          autoSize = _props.autoSize,
          rows = _props.rows,
          size = _props.size,
          value = _props.value;
      var prevAutoSize = prevProps.autoSize,
          prevRows = prevProps.rows,
          prevSize = prevProps.size,
          prevValue = prevProps.value;


      if (autoSize && (!prevAutoSize || value !== prevValue || rows !== prevRows || size !== prevSize)) {
        this.autoSize();
      }

      if (!autoSize && prevAutoSize) {
        this.removeAutoSize();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props2 = this.props,
          autoSize = _props2.autoSize,
          className = _props2.className,
          disabled = _props2.disabled,
          inputRef = _props2.inputRef,
          invalid = _props2.invalid,
          readOnly = _props2.readOnly,
          required = _props2.required,
          _props2$resizeable = _props2.resizeable,
          resizeable = _props2$resizeable === undefined ? true : _props2$resizeable,
          otherRootProps = _props2.rootProps,
          rows = _props2.rows,
          _props2$size = _props2.size,
          size = _props2$size === undefined ? 'large' : _props2$size,
          variant = _props2.variant,
          restProps = _objectWithoutProperties(_props2, ['autoSize', 'className', 'disabled', 'inputRef', 'invalid', 'readOnly', 'required', 'resizeable', 'rootProps', 'rows', 'size', 'variant']);

      var textAreaProps = _extends({
        'aria-invalid': invalid,
        'aria-required': required,
        autoSize: autoSize,
        controlRef: function controlRef(ref) {
          _this2.textArea = ref;
          if (inputRef) {
            inputRef(ref);
          }
        },
        disabled: disabled,
        onInput: this.handleInput,
        readOnly: readOnly,
        required: required,
        resizeable: autoSize ? false : resizeable,
        rows: rows || size && sizeToRows[size] || undefined,
        size: size
      }, restProps);

      var rootProps = _extends({
        className: className,
        control: _TextArea,
        controlProps: textAreaProps,
        disabled: disabled,
        iconEnd: null, // Opt out of the variant icon
        readOnly: readOnly,
        size: size,
        variant: variant
      }, otherRootProps);

      return _react2.default.createElement(Root, rootProps);
    }
  }]);

  return TextArea;
}(_react.Component);

exports.default = TextArea;
TextArea.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Automatically adjust the height of the input to fit the content */
  autoSize: _propTypes2.default.bool,

  /** @Private CSS className */
  className: _propTypes2.default.string,

  /** Initial value of the input. Primarily for use with uncontrolled components */
  defaultValue: _propTypes2.default.string,

  /** Disables the input */
  disabled: _propTypes2.default.bool,

  /** ref for the input */
  inputRef: _propTypes2.default.func,

  /** Props to be applied directly to the root element, rather than the input */
  rootProps: _propTypes2.default.object,

  /** Indicates that the value of the element is invalid */
  invalid: _propTypes2.default.bool,

  /**
   * @Private Used internally in conjunction with autoSize prop. Must also
   * support a custom function.
   */
  onInput: _propTypes2.default.func,

  /** Function called when input value changes */
  onChange: _propTypes2.default.func,

  /** Indicates that the user cannot modify the value of the input */
  readOnly: _propTypes2.default.bool,

  /** Indicates that the user must fill in a value before submitting a form */
  required: _propTypes2.default.bool,

  /** Indicates whether input is resizable. _Not currently supported in IE/Edge._ */
  resizeable: _propTypes2.default.bool,

  /** The number of visible text lines in the input */
  rows: _propTypes2.default.number,

  /** Available sizes */
  size: _propTypes2.default.oneOf(['small', 'medium', 'large', 'jumbo']),

  /**
   * The initial value of the input. Primarily for use with controlled
   * components.  If this prop is specified, an onChange handler must also be
   * specified.  Also see `defaultValue`.
   */
  value: _propTypes2.default.string,

  /** Available variants */
  variant: _propTypes2.default.oneOf(['success', 'warning', 'danger'])
} : {};