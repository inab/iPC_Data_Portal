'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.componentTheme = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _styles = require('../styles');

var _themes = require('../themes');

var _FauxControl = require('../FauxControl/FauxControl');

var _FauxControl2 = _interopRequireDefault(_FauxControl);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var componentTheme = exports.componentTheme = function componentTheme(baseTheme) {
  return (0, _themes.mapComponentThemes)({
    name: 'FauxControl',
    theme: (0, _FauxControl.componentTheme)(baseTheme)
  }, {
    name: 'TextInput',
    theme: {
      TextInput_height_small: baseTheme.size_small,
      TextInput_height_medium: baseTheme.size_medium,
      TextInput_height_large: baseTheme.size_large,
      TextInput_height_jumbo: baseTheme.size_jumbo,

      TextInputIcon_color: baseTheme.color_gray_40
    }
  }, baseTheme);
};

var ThemedFauxControl = (0, _themes.createThemedComponent)(_FauxControl2.default, function (_ref) {
  var baseTheme = _ref.theme;
  return (0, _themes.mapComponentThemes)({
    name: 'TextInput',
    theme: componentTheme(baseTheme)
  }, {
    name: 'FauxControl',
    theme: {}
  }, baseTheme);
});

var styles = {
  input: function input(_ref2) {
    var controlSize = _ref2.controlSize,
        nonHtmlSize = _ref2.size,
        baseTheme = _ref2.theme;

    var theme = componentTheme(baseTheme);

    var size = controlSize || nonHtmlSize;
    var fontSize = size === 'small' ? theme.TextInput_fontSize_small : theme.TextInput_fontSize;

    return {
      backgroundColor: 'transparent',
      border: 0,
      boxShadow: 'none',
      flex: '1 1 auto',
      fontFamily: 'inherit',
      height: (0, _styles.getNormalizedValue)(theme['TextInput_height_' + size], fontSize),
      minWidth: 0,
      width: '100%',

      // Normalize Safari search inputs
      '&[type="search"]': {
        WebkitAppearance: 'none',

        '&::-webkit-search-decoration': {
          WebkitAppearance: 'none'
        }
      }
    };
  },
  root: function root(_ref3) {
    var baseTheme = _ref3.theme,
        variant = _ref3.variant;

    var theme = componentTheme(baseTheme);

    if (variant) {
      theme = _extends({}, theme, {
        TextInputIcon_color: theme['icon_color_' + variant]
      });
    }

    return {
      alignItems: 'center',
      cursor: 'text',
      display: 'flex',
      width: '100%',

      '& [role="img"]': {
        color: theme.TextInputIcon_color,
        display: 'block',
        flex: '0 0 auto',
        margin: '0 ' + theme.TextInputIcon_marginHorizontal,

        '&:last-of-type': {
          color: theme.TextInputIcon_color
        }
      }
    };
  }
};

var Root = (0, _styles.createStyledComponent)(ThemedFauxControl, styles.root, {
  displayName: 'TextInput'
});
var Input = (0, _styles.createStyledComponent)('input', styles.input, {
  displayName: 'Input',
  rootEl: 'input',
  forwardProps: ['size']
});

/**
 * TextInput allows your app to accept a text value from the user. It supports
 * any of the text-based input types, such as `text`, `number` or `email`.
 */
var TextInput = function TextInput(props) {
  var className = props.className,
      disabled = props.disabled,
      iconEnd = props.iconEnd,
      iconStart = props.iconStart,
      inputRef = props.inputRef,
      invalid = props.invalid,
      prefix = props.prefix,
      readOnly = props.readOnly,
      required = props.required,
      otherRootProps = props.rootProps,
      size = props.size,
      suffix = props.suffix,
      variant = props.variant,
      restProps = _objectWithoutProperties(props, ['className', 'disabled', 'iconEnd', 'iconStart', 'inputRef', 'invalid', 'prefix', 'readOnly', 'required', 'rootProps', 'size', 'suffix', 'variant']);

  var inputProps = _extends({
    'aria-invalid': invalid,
    'aria-required': required,
    controlRef: inputRef,
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }, restProps);

  var rootProps = _extends({
    className: className,
    control: Input,
    controlProps: inputProps,
    disabled: disabled,
    iconEnd: iconEnd,
    iconStart: iconStart,
    prefix: prefix,
    readOnly: readOnly,
    size: size,
    suffix: suffix,
    variant: variant
  }, otherRootProps);

  return _react2.default.createElement(Root, rootProps);
};

TextInput.propTypes = process.env.NODE_ENV !== "production" ? {
  /** @Private CSS className */
  className: _propTypes2.default.string,

  /** Initial value of the input. Primarily for use with uncontrolled components */
  defaultValue: _propTypes2.default.string,

  /** Disables the input */
  disabled: _propTypes2.default.bool,

  /** HTML `size` attribute */
  htmlSize: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),

  /** Icon located at the start of the input */
  iconStart: function iconStart() {
    return (typeof React$Element === 'function' ? _propTypes2.default.instanceOf(React$Element) : _propTypes2.default.any).apply(this, arguments);
  },

  /** Icon located at the end of the input */
  iconEnd: function iconEnd() {
    return (typeof React$Element === 'function' ? _propTypes2.default.instanceOf(React$Element) : _propTypes2.default.any).apply(this, arguments);
  },

  /** ref for the input */
  inputRef: _propTypes2.default.func,

  /** Props to be applied directly to the root element, rather than the input */
  rootProps: _propTypes2.default.object,

  /** Indicates that the value of the element is invalid */
  invalid: _propTypes2.default.bool,

  /** Function called when input value changes */
  onChange: _propTypes2.default.func,

  /** Text to display before input value */
  prefix: _propTypes2.default.oneOfType([_propTypes2.default.string, function () {
    return (typeof React$Element === 'function' ? _propTypes2.default.instanceOf(React$Element) : _propTypes2.default.any).apply(this, arguments);
  }]),

  /** Indicates that the user cannot modify the value of the input */
  readOnly: _propTypes2.default.bool,

  /** Indicates that the user must fill in a value before submitting a form */
  required: _propTypes2.default.bool,

  /** Available sizes */
  size: _propTypes2.default.oneOf(['small', 'medium', 'large', 'jumbo']),

  /** Text to display after input value */
  suffix: _propTypes2.default.oneOfType([_propTypes2.default.string, function () {
    return (typeof React$Element === 'function' ? _propTypes2.default.instanceOf(React$Element) : _propTypes2.default.any).apply(this, arguments);
  }]),

  /** Type of input. Not all types are equally supported across browsers. */
  type: _propTypes2.default.oneOf(['date', 'datetime-local', 'email', 'month', 'number', 'password', 'search', 'tel', 'text', 'time', 'url', 'week']),

  /**
   * The initial value of the input. Primarily for use with controlled
   * components.  If this prop is specified, an onChange handler must also be
   * specified.  Also see `defaultValue`.
   */
  value: _propTypes2.default.string,

  /** Available variants */
  variant: _propTypes2.default.oneOf(['success', 'warning', 'danger'])
} : {};
TextInput.defaultProps = {
  size: 'large',
  type: 'text'
};

exports.default = TextInput;