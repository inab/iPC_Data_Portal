'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.componentTheme = undefined;

var _jsx = function () { var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; return function createRawReactElement(type, props, key, children) { var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = {}; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _styles = require('../styles');

var _utils = require('../utils');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var REGEX_GROUP = /(Checkbox|Radio|Group)/i;

// [1] This deviates from h6 because it must look right when used both within
//     and without a FormFieldset
var componentTheme = exports.componentTheme = function componentTheme(baseTheme) {
  return _extends({
    FormFieldCaption_color: baseTheme.color_mouse,
    FormFieldCaption_fontSize: baseTheme.fontSize_mouse,
    FormFieldCaption_marginTop: baseTheme.space_stack_xxs,
    FormFieldCaption_marginTop_isGroup: baseTheme.space_stack_sm,

    FormFieldLabel_color: baseTheme.h6_color,
    FormFieldLabel_fontSize: baseTheme.h6_fontSize,
    FormFieldLabel_fontWeight: baseTheme.fontWeight_semiBold, // [1]
    FormFieldLabel_marginBottom: baseTheme.space_stack_sm,

    FormFieldSecondaryText_fontSize: baseTheme.fontSize_mouse,
    FormFieldSecondaryText_color: baseTheme.color_mouse,
    FormFieldSecondaryText_color_required: baseTheme.color_required,
    FormFieldSecondaryText_fontWeight: baseTheme.fontWeight_regular

  }, baseTheme);
};

var styles = {
  caption: function caption(_ref) {
    var isGroup = _ref.isGroup,
        baseTheme = _ref.theme,
        variant = _ref.variant;

    var theme = componentTheme(baseTheme);
    if (variant) {
      // prettier-ignore
      theme = _extends({}, theme, {
        FormFieldCaption_color: baseTheme['color_' + variant]
      });
    }

    var fontSize = theme.FormFieldCaption_fontSize;

    return {
      color: theme.FormFieldCaption_color,
      fontSize: fontSize,
      marginTop: isGroup ? (0, _styles.getNormalizedValue)(theme.FormFieldCaption_marginTop_isGroup, fontSize) : (0, _styles.getNormalizedValue)(theme.FormFieldCaption_marginTop, fontSize)
    };
  },
  textWrapper: function textWrapper(_ref2) {
    var hideLabel = _ref2.hideLabel,
        baseTheme = _ref2.theme;

    var theme = componentTheme(baseTheme);

    return _extends({
      color: theme.FormFieldLabel_color,
      display: 'flex',
      fontSize: theme.FormFieldLabel_fontSize,
      fontWeight: theme.FormFieldLabel_fontWeight,
      justifyContent: 'space-between',
      marginBottom: theme.FormFieldLabel_marginBottom
    }, hideLabel ? {
      border: '0',
      clip: 'rect(0 0 0 0)',
      clipPath: 'inset(50%)',
      height: '1px',
      margin: '-1px',
      overflow: 'hidden',
      padding: '0',
      position: 'absolute',
      whiteSpace: 'nowrap',
      width: '1px'
    } : {}, {
      '& > *': {
        alignSelf: 'flex-end',
        display: 'inline-block'
      }
    });
  },
  secondaryText: function (_secondaryText) {
    function secondaryText(_x) {
      return _secondaryText.apply(this, arguments);
    }

    secondaryText.toString = function () {
      return _secondaryText.toString();
    };

    return secondaryText;
  }(function (_ref3) {
    var secondaryText = _ref3.secondaryText,
        baseTheme = _ref3.theme;

    var theme = componentTheme(baseTheme);

    return {
      color: secondaryText ? theme.FormFieldSecondaryText_color : theme.FormFieldSecondaryText_color_required,
      fontSize: theme.FormFieldSecondaryText_fontSize,
      fontWeight: theme.FormFieldSecondaryText_fontWeight
    };
  })
};

var Root = (0, _styles.createStyledComponent)('div', {}, {
  displayName: 'FormField',
  includeStyleReset: true
});
var TextWrapper = (0, _styles.createStyledComponent)('div', styles.textWrapper);
var SecondaryText = (0, _styles.createStyledComponent)('span', styles.secondaryText);
var Caption = (0, _styles.createStyledComponent)('div', styles.caption);

/**
 * The FormField component enhances form inputs with an accessible label and
 * optionally displays additional help text.
 */

var FormField = function (_Component) {
  _inherits(FormField, _Component);

  function FormField() {
    var _ref4;

    var _temp, _this, _ret;

    _classCallCheck(this, FormField);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref4 = FormField.__proto__ || Object.getPrototypeOf(FormField)).call.apply(_ref4, [this].concat(args))), _this), _this.id = _this.props.id || 'formField-' + (0, _utils.generateId)(), _this.getControlName = function () {
      var _this$props = _this.props,
          children = _this$props.children,
          input = _this$props.input;

      var controlName = void 0;

      if (input && input.displayName) {
        controlName = input.displayName;
      } else if (children) {
        var child = _react.Children.only(children);
        if (child.type && child.type.displayName) {
          controlName = child.type.displayName;
        }
      }

      return controlName;
    }, _this.isGroup = function () {
      var controlName = _this.getControlName();

      return controlName && REGEX_GROUP.test(controlName);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(FormField, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          caption = _props.caption,
          children = _props.children,
          className = _props.className,
          hideLabel = _props.hideLabel,
          input = _props.input,
          label = _props.label,
          required = _props.required,
          requiredText = _props.requiredText,
          otherRootProps = _props.rootProps,
          secondaryText = _props.secondaryText,
          variant = _props.variant,
          restProps = _objectWithoutProperties(_props, ['caption', 'children', 'className', 'hideLabel', 'input', 'label', 'required', 'requiredText', 'rootProps', 'secondaryText', 'variant']);

      var rootProps = _extends({
        className: className
      }, otherRootProps);

      // Label structure differs if input/control is a grouped control which has
      // its own label tag.  e.g. Radio, Checkbox, RadioGroup, CheckboxGroup
      var isGroup = this.isGroup();
      var Label = isGroup ? 'div' : 'label';

      var textWrapperProps = {
        hideLabel: hideLabel,
        key: this.id + '-textWrapper'
      };

      var labelTextProps = {
        id: this.id + '-labelText'
      };

      var captionProps = {
        caption: caption,
        isGroup: isGroup,
        variant: variant,
        id: this.id + '-caption'
      };

      var controlProps = function controlProps() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        return _extends({
          'aria-describedby': caption && captionProps.id,
          key: _this2.id + '-control',
          required: required,
          rootProps: isGroup ? _extends({
            'aria-labelledby': labelTextProps.id,
            'aria-describedby': caption && captionProps.id
          }, props.rootProps) : props.rootProps,
          variant: variant
        }, restProps);
      };

      var control = null;
      if (input) {
        control = (0, _react.createElement)(input, controlProps());
      } else if (children) {
        var child = _react.Children.only(children);
        control = (0, _react.cloneElement)(child, controlProps(child.props));
      }

      return _react2.default.createElement(
        Root,
        rootProps,
        _jsx(Label, {}, void 0, _react2.default.createElement(
          TextWrapper,
          textWrapperProps,
          _react2.default.createElement(
            'span',
            labelTextProps,
            label
          ),
          (required || secondaryText) && _jsx(SecondaryText, {
            secondaryText: secondaryText
          }, void 0, secondaryText ? secondaryText : requiredText)
        ), control),
        caption && _react2.default.createElement(
          Caption,
          captionProps,
          caption
        )
      );
    }
  }]);

  return FormField;
}(_react.Component);

FormField.defaultProps = {
  requiredText: 'Required'
};
exports.default = FormField;
FormField.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * Caption associated with the input element; commonly used to provide help
   * text
   */
  caption: _propTypes2.default.oneOfType([_propTypes2.default.string, function () {
    return (typeof React$Element === 'function' ? _propTypes2.default.instanceOf(React$Element) : _propTypes2.default.any).apply(this, arguments);
  }]),

  /** Form input element */
  children: function children() {
    return (typeof React$Node === 'function' ? _propTypes2.default.instanceOf(React$Node) : _propTypes2.default.any).apply(this, arguments);
  },

  /** @Private CSS className */
  className: _propTypes2.default.string,

  /** Visually hide label, but keep available for [assistive technologies](https://webaccess.berkeley.edu/resources/assistive-technology) */
  hideLabel: _propTypes2.default.bool,

  /** Id of the FormField */
  id: _propTypes2.default.string,

  /** Form input class; alternative to `children` */
  input: function input() {
    return (typeof React$ComponentType === 'function' ? _propTypes2.default.instanceOf(React$ComponentType) : _propTypes2.default.any).apply(this, arguments);
  },

  /** Props to be applied directly to the root element, rather than the input */
  rootProps: _propTypes2.default.object,

  /** Label associated with the input element */
  label: _propTypes2.default.oneOfType([_propTypes2.default.string, function () {
    return (typeof React$Element === 'function' ? _propTypes2.default.instanceOf(React$Element) : _propTypes2.default.any).apply(this, arguments);
  }]).isRequired,

  /** Marks associated input as required */
  required: _propTypes2.default.bool,

  /** Text used to indicate a required field */
  requiredText: _propTypes2.default.oneOfType([_propTypes2.default.string, function () {
    return (typeof React$Element === 'function' ? _propTypes2.default.instanceOf(React$Element) : _propTypes2.default.any).apply(this, arguments);
  }]),

  /**
   * Secondary text associated with the input element; takes precedence over
   * `requiredText`
   */
  secondaryText: _propTypes2.default.oneOfType([_propTypes2.default.string, function () {
    return (typeof React$Element === 'function' ? _propTypes2.default.instanceOf(React$Element) : _propTypes2.default.any).apply(this, arguments);
  }]),

  /** Available variants */
  variant: _propTypes2.default.oneOf(['success', 'warning', 'danger'])
} : {};