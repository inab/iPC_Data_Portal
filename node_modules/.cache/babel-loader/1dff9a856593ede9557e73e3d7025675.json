{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = _default;\nexports.opSwitch = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _constants = require(\"../constants\");\n\nvar _normalizeFilters = _interopRequireDefault(require(\"./normalizeFilters\"));\n\nvar _esFilter = require(\"../utils/esFilter\");\n\nvar _wrappers;\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar wrapFilter = function wrapFilter(_ref) {\n  var esFilter = _ref.esFilter,\n      nestedFields = _ref.nestedFields,\n      filter = _ref.filter,\n      isNot = _ref.isNot;\n  return filter.content.field.split('.').slice(0, -1).map(function (p, i, segments) {\n    return segments.slice(0, i + 1).join('.');\n  }).filter(function (p) {\n    return nestedFields.includes(p);\n  }).reverse().reduce(function (esFilter, path, i) {\n    return (0, _esFilter.wrapNested)(esFilter, path);\n  }, isNot ? (0, _esFilter.wrapMustNot)(esFilter) : esFilter);\n};\n\nfunction getRegexFilter(_ref2) {\n  var nestedFields = _ref2.nestedFields,\n      filter = _ref2.filter;\n\n  var op = filter.op,\n      _filter$content = filter.content,\n      field = _filter$content.field,\n      _filter$content$value = _slicedToArray(_filter$content.value, 1),\n      value = _filter$content$value[0];\n\n  var esFilter = wrapFilter({\n    filter: filter,\n    nestedFields: nestedFields,\n    esFilter: {\n      regexp: _defineProperty({}, field, value.replace('*', '.*'))\n    },\n    isNot: _constants.NOT_IN_OP === op\n  });\n  return op === _constants.SOME_NOT_IN_OP ? (0, _esFilter.wrapMustNot)(esFilter) : esFilter;\n}\n\nfunction getTermFilter(_ref3) {\n  var _terms;\n\n  var nestedFields = _ref3.nestedFields,\n      filter = _ref3.filter;\n  var op = filter.op,\n      _filter$content2 = filter.content,\n      value = _filter$content2.value,\n      field = _filter$content2.field;\n  var esFilter = wrapFilter({\n    filter: filter,\n    nestedFields: nestedFields,\n    esFilter: {\n      terms: (_terms = {}, _defineProperty(_terms, field, value.map(function (item) {\n        return item || '';\n      })), _defineProperty(_terms, \"boost\", 0), _terms)\n    },\n    isNot: _constants.NOT_IN_OP === op\n  });\n  return op === _constants.SOME_NOT_IN_OP ? (0, _esFilter.wrapMustNot)(esFilter) : esFilter;\n}\n\nfunction getFuzzyFilter(_ref4) {\n  var nestedFields = _ref4.nestedFields,\n      filter = _ref4.filter;\n  var content = filter.content;\n  var value = content.value,\n      fields = content.fields; // group queries by their nesting level\n\n  var sortedNested = nestedFields.slice().sort(function (a, b) {\n    return b.length - a.length;\n  });\n  var nestedMap = fields.reduce(function (acc, field) {\n    var group = sortedNested.find(function (y) {\n      return field.includes(y);\n    }) || '';\n\n    if (acc[group]) {\n      acc[group].push(field);\n    } else {\n      acc[group] = [field];\n    }\n\n    return acc;\n  }, {}); // construct one multi match per nested group\n\n  return (0, _esFilter.wrapShould)(Object.values(nestedMap).map(function (fields) {\n    return wrapFilter({\n      filter: _objectSpread({}, filter, {\n        content: _objectSpread({}, content, {\n          field: fields[0]\n        })\n      }),\n      nestedFields: nestedFields,\n      esFilter: (0, _esFilter.wrapShould)(fields.map(function (field) {\n        return _defineProperty({}, _constants.ES_WILDCARD, _defineProperty({}, field, {\n          value: \"\".concat(value)\n        }));\n      }))\n    });\n  }));\n}\n\nfunction getMissingFilter(_ref6) {\n  var nestedFields = _ref6.nestedFields,\n      filter = _ref6.filter;\n  var field = filter.content.field;\n  return wrapFilter({\n    esFilter: {\n      exists: {\n        field: field,\n        boost: 0\n      }\n    },\n    nestedFields: nestedFields,\n    filter: filter,\n    isNot: true\n  });\n}\n\nfunction getRangeFilter(_ref7) {\n  var nestedFields = _ref7.nestedFields,\n      filter = _ref7.filter;\n  var op = filter.op,\n      _filter$content3 = filter.content,\n      field = _filter$content3.field,\n      value = _filter$content3.value;\n  return wrapFilter({\n    filter: filter,\n    nestedFields: nestedFields,\n    esFilter: {\n      range: _defineProperty({}, field, _defineProperty({\n        boost: 0\n      }, op, (0, _esFilter.toEsRangeValue)([_constants.GT_OP, _constants.GTE_OP].includes(op) ? _lodash[\"default\"].max(value) : _lodash[\"default\"].min(value))))\n    }\n  });\n}\n\nfunction collapseNestedFilters(_ref8) {\n  var esFilter = _ref8.esFilter,\n      bools = _ref8.bools;\n  var filterIsNested = (0, _esFilter.isNested)(esFilter);\n  var basePath = [].concat(_toConsumableArray(filterIsNested ? [_constants.ES_NESTED, _constants.ES_QUERY] : []), [_constants.ES_BOOL]);\n  var path = [_constants.ES_MUST, _constants.ES_MUST_NOT].map(function (p) {\n    return [].concat(_toConsumableArray(basePath), [p]);\n  }).find(function (path) {\n    return _lodash[\"default\"].get(esFilter, path);\n  });\n  var found = path && bools.find(function (bool) {\n    return filterIsNested ? (0, _esFilter.readPath)(bool) === (0, _esFilter.readPath)(esFilter) : _lodash[\"default\"].get(bool, path);\n  });\n  return [].concat(_toConsumableArray(bools.filter(function (bool) {\n    return bool !== found;\n  })), [found ? (0, _esFilter.mergePath)(found, path, filterIsNested ? collapseNestedFilters({\n    esFilter: _lodash[\"default\"].get(esFilter, path)[0],\n    bools: _lodash[\"default\"].get(found, path, [])\n  }) : [].concat(_toConsumableArray(_lodash[\"default\"].get(found, path)), _toConsumableArray(_lodash[\"default\"].get(esFilter, path)))) : esFilter]);\n}\n\nvar wrappers = (_wrappers = {}, _defineProperty(_wrappers, _constants.AND_OP, _esFilter.wrapMust), _defineProperty(_wrappers, _constants.OR_OP, _esFilter.wrapShould), _defineProperty(_wrappers, _constants.NOT_OP, _esFilter.wrapMustNot), _wrappers);\n\nfunction getGroupFilter(_ref9) {\n  var _esFilters$, _esFilters$2;\n\n  var nestedFields = _ref9.nestedFields,\n      _ref9$filter = _ref9.filter,\n      content = _ref9$filter.content,\n      op = _ref9$filter.op,\n      pivot = _ref9$filter.pivot;\n  var applyBooleanWrapper = wrappers[op];\n  var esFilters = content.map(function (filter) {\n    return opSwitch({\n      nestedFields: nestedFields,\n      filter: filter\n    });\n  });\n  var isNested = !!((_esFilters$ = esFilters[0]) === null || _esFilters$ === void 0 ? void 0 : _esFilters$.nested);\n\n  if (isNested && pivot === ((_esFilters$2 = esFilters[0]) === null || _esFilters$2 === void 0 ? void 0 : _esFilters$2.nested.path)) {\n    var flattned = esFilters.reduce(function (bools, esFilter) {\n      return op === _constants.AND_OP || op === _constants.NOT_OP ? collapseNestedFilters({\n        esFilter: esFilter,\n        bools: bools\n      }) : [].concat(_toConsumableArray(bools), [esFilter]);\n    }, []);\n    return applyBooleanWrapper(flattned);\n  } else {\n    return applyBooleanWrapper(esFilters);\n  }\n}\n\nfunction getSetFilter(_ref10) {\n  var nestedFields = _ref10.nestedFields,\n      filter = _ref10.filter,\n      _ref10$filter = _ref10.filter,\n      content = _ref10$filter.content,\n      op = _ref10$filter.op;\n  return wrapFilter({\n    isNot: op === _constants.NOT_IN_OP,\n    filter: filter,\n    nestedFields: nestedFields,\n    esFilter: {\n      terms: _defineProperty({\n        boost: 0\n      }, content.field, {\n        index: _constants.ES_ARRANGER_SET_INDEX,\n        type: _constants.ES_ARRANGER_SET_TYPE,\n        id: _lodash[\"default\"].flatMap([content.value])[0].replace('set_id:', ''),\n        path: 'ids'\n      })\n    }\n  });\n}\n\nvar getBetweenFilter = function getBetweenFilter(_ref11) {\n  var _field2;\n\n  var nestedFields = _ref11.nestedFields,\n      filter = _ref11.filter;\n  var _filter$content4 = filter.content,\n      field = _filter$content4.field,\n      value = _filter$content4.value;\n  return wrapFilter({\n    filter: filter,\n    nestedFields: nestedFields,\n    esFilter: {\n      range: _defineProperty({}, field, (_field2 = {\n        boost: 0\n      }, _defineProperty(_field2, _constants.GTE_OP, _lodash[\"default\"].min(value)), _defineProperty(_field2, _constants.LTE_OP, _lodash[\"default\"].max(value)), _field2))\n    }\n  });\n};\n\nvar opSwitch = function opSwitch(_ref12) {\n  var nestedFields = _ref12.nestedFields,\n      filter = _ref12.filter;\n  var op = filter.op,\n      pivot = filter.pivot,\n      value = filter.content.value; // we need a way to handle object fields before the following error is valid\n  // if (pivot && pivot !== '.' && !nestedFields.includes(pivot)) {\n  //   throw new Error(`Invalid pivot field \"${pivot}\", not a nested field`);\n  // }\n\n  if ([_constants.OR_OP, _constants.AND_OP, _constants.NOT_OP].includes(op)) {\n    return getGroupFilter({\n      nestedFields: nestedFields,\n      filter: filter\n    });\n  } else if ([_constants.IN_OP, _constants.NOT_IN_OP, _constants.SOME_NOT_IN_OP].includes(op)) {\n    if (\"\".concat(value[0]).includes(_constants.REGEX)) {\n      return getRegexFilter({\n        nestedFields: nestedFields,\n        filter: filter\n      });\n    } else if (\"\".concat(value[0]).includes(_constants.SET_ID)) {\n      return getSetFilter({\n        nestedFields: nestedFields,\n        filter: filter\n      });\n    } else if (\"\".concat(value[0]).includes(_constants.MISSING)) {\n      return getMissingFilter({\n        nestedFields: nestedFields,\n        filter: filter\n      });\n    } else {\n      return getTermFilter({\n        nestedFields: nestedFields,\n        filter: filter\n      });\n    }\n  } else if ([_constants.ALL_OP].includes(op)) {\n    return getGroupFilter({\n      nestedFields: nestedFields,\n      filter: {\n        op: _constants.AND_OP,\n        pivot: pivot || '.',\n        content: filter.content.value.map(function (v) {\n          return {\n            op: _constants.IN_OP,\n            content: {\n              field: filter.content.field,\n              value: [v]\n            }\n          };\n        })\n      }\n    });\n  } else if ([_constants.GT_OP, _constants.GTE_OP, _constants.LT_OP, _constants.LTE_OP].includes(op)) {\n    return getRangeFilter({\n      nestedFields: nestedFields,\n      filter: filter\n    });\n  } else if ([_constants.BETWEEN_OP].includes(op)) {\n    return getBetweenFilter({\n      nestedFields: nestedFields,\n      filter: filter\n    });\n  } else if (_constants.FILTER_OP === op) {\n    return getFuzzyFilter({\n      nestedFields: nestedFields,\n      filter: filter\n    });\n  } else {\n    throw new Error('unknown op');\n  }\n};\n\nexports.opSwitch = opSwitch;\n\nfunction _default(_ref13) {\n  var nestedFields = _ref13.nestedFields,\n      rawFilters = _ref13.filters;\n  if (Object.keys(rawFilters || {}).length === 0) return {};\n  return opSwitch({\n    nestedFields: nestedFields,\n    filter: (0, _normalizeFilters[\"default\"])(rawFilters)\n  });\n}","map":null,"metadata":{},"sourceType":"script"}