{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _recompose = require(\"recompose\");\n\nvar _jsonpath = _interopRequireDefault(require(\"jsonpath/jsonpath.min\"));\n\nvar _reactScrollbarSize = _interopRequireDefault(require(\"react-scrollbar-size\"));\n\nvar _style = _interopRequireDefault(require(\"./style\"));\n\nvar _EnhancedReactTable = _interopRequireDefault(require(\"./EnhancedReactTable\"));\n\nvar _CustomPagination = _interopRequireDefault(require(\"./CustomPagination\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar enhance = (0, _recompose.compose)((0, _recompose.defaultProps)({\n  setSelectedTableRows: _lodash.noop,\n  onPaginationChange: _lodash.noop,\n  selectedTableRows: null\n}));\n\nvar DataTable =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(DataTable, _React$Component);\n\n  function DataTable(props) {\n    var _this;\n\n    _classCallCheck(this, DataTable);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DataTable).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"setSelectedTableRows\", function (selectedTableRows) {\n      _this.props.setSelectedTableRows(selectedTableRows);\n\n      _this.setState({\n        selectedTableRows: selectedTableRows\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"toggleSelectedTableRow\", function (key) {\n      // react-table does some weird stuff and passes `select-${}` for some reason\n      var sanitizedKey = key.split('select-').join('');\n      var selectedTableRows = (0, _lodash.xor)(_this.state.selectedTableRows, [sanitizedKey]);\n\n      _this.setSelectedTableRows(selectedTableRows);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"toggleAll\", function () {\n      var selectedTableRows = _this.state.selectedTableRows.length === _this.state.data.length ? [] : _this.state.data.map(function (item) {\n        return item[_this.props.config.keyField];\n      });\n\n      _this.setSelectedTableRows(selectedTableRows);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"isSelected\", function (key) {\n      return _this.state.selectedTableRows.includes(key);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onFetchData\", function (state) {\n      var _this$props = _this.props,\n          fetchData = _this$props.fetchData,\n          config = _this$props.config,\n          sqon = _this$props.sqon,\n          _this$props$alwaysSor = _this$props.alwaysSorted,\n          alwaysSorted = _this$props$alwaysSor === void 0 ? [] : _this$props$alwaysSor,\n          keepSelectedOnPageChange = _this$props.keepSelectedOnPageChange;\n      var selectedTableRows = _this.state.selectedTableRows;\n\n      _this.setState({\n        loading: true,\n        lastState: state\n      });\n\n      fetchData === null || fetchData === void 0 ? void 0 : fetchData({\n        config: config,\n        sqon: sqon,\n        queryName: 'Table',\n        sort: [].concat(_toConsumableArray(state.sorted.map(function (sort) {\n          return {\n            field: sort.id,\n            order: sort.desc ? 'desc' : 'asc'\n          };\n        })), _toConsumableArray(alwaysSorted)),\n        offset: state.page * state.pageSize,\n        first: state.pageSize\n      }).then(function (_ref) {\n        var total = _ref.total,\n            data = _ref.data;\n\n        if (total !== _this.state.total) {\n          _this.props.onPaginationChange({\n            total: total\n          });\n        }\n\n        _this.setState({\n          data: data,\n          total: total,\n          pages: Math.ceil(total / state.pageSize),\n          loading: false\n        });\n\n        if (!keepSelectedOnPageChange) {\n          _this.setSelectedTableRows((0, _lodash.intersection)(data.map(function (item) {\n            return item[_this.props.config.keyField];\n          }), selectedTableRows));\n        }\n      })[\"catch\"](function (err) {\n        console.error(err);\n\n        _this.setState({\n          loading: false\n        });\n      });\n    });\n\n    _this.state = {\n      selectedTableRows: props.selectedTableRows || props.initalSelectedTableRows || [],\n      data: [],\n      pages: -1,\n      loading: false,\n      lastState: null,\n      scrollbarSize: {}\n    };\n    return _this;\n  }\n\n  _createClass(DataTable, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(lastProps) {\n      var _this2 = this;\n\n      if (!this.state.loading && lastProps.config.columns.some(function (lastColumn, i) {\n        return lastColumn.show !== _this2.props.config.columns[i].show;\n      })) {\n        this.onFetchData(this.state.lastState);\n      } // TODO: in receive props? better if else ladder?\n\n\n      if (this.props.sqon !== lastProps.sqon) {\n        this.onFetchData(this.state.lastState);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var toggleSelectedTableRow = this.toggleSelectedTableRow,\n          toggleAll = this.toggleAll,\n          isSelected = this.isSelected,\n          onFetchData = this.onFetchData;\n      var _this$props2 = this.props,\n          config = _this$props2.config,\n          defaultPageSize = _this$props2.defaultPageSize,\n          onSortedChange = _this$props2.onSortedChange,\n          propsData = _this$props2.propsData,\n          propsLoading = _this$props2.loading,\n          style = _this$props2.style,\n          maxPagesOptions = _this$props2.maxPagesOptions;\n      var columns = config.columns,\n          keyField = config.keyField,\n          defaultSorted = config.defaultSorted;\n      var _this$state = this.state,\n          data = _this$state.data,\n          selectedTableRows = _this$state.selectedTableRows,\n          pages = _this$state.pages,\n          loading = _this$state.loading,\n          scrollbarSize = _this$state.scrollbarSize;\n      var fetchFromServerProps = {\n        pages: pages,\n        loading: propsLoading !== null ? propsLoading : loading,\n        manual: true,\n        onFetchData: onFetchData\n      };\n      var checkboxProps = {\n        selectAll: selectedTableRows.length === data.length,\n        isSelected: isSelected,\n        toggleSelection: toggleSelectedTableRow,\n        toggleAll: toggleAll,\n        selectType: 'checkbox',\n        keyField: keyField\n      };\n      return _react[\"default\"].createElement(_react[\"default\"].Fragment, null, _react[\"default\"].createElement(_reactScrollbarSize[\"default\"], {\n        onLoad: function onLoad(scrollbarSize) {\n          return _this3.setState({\n            scrollbarSize: scrollbarSize\n          });\n        },\n        onChange: function onChange(scrollbarSize) {\n          return _this3.setState({\n            scrollbarSize: scrollbarSize\n          });\n        }\n      }), _react[\"default\"].createElement(_EnhancedReactTable[\"default\"], _extends({\n        minRows: 0,\n        className: \"-striped -highlight \".concat((0, _style[\"default\"])({\n          scrollbarSize: scrollbarSize\n        })),\n        style: style,\n        onSortedChange: onSortedChange,\n        onPageChange: function onPageChange(page) {\n          return _this3.props.onPaginationChange({\n            page: page\n          });\n        },\n        onPageSizeChange: function onPageSizeChange(pageSize, page) {\n          return _this3.props.onPaginationChange({\n            pageSize: pageSize,\n            page: page\n          });\n        },\n        data: (propsData === null || propsData === void 0 ? void 0 : propsData.data) || data,\n        defaultSorted: defaultSorted,\n        columns: columns.map(function (_ref2) {\n          var Cell = _ref2.Cell,\n              c = _objectWithoutProperties(_ref2, [\"Cell\"]);\n\n          return _objectSpread({}, c, {}, !c.hasCustomType && !(0, _lodash.isEmpty)(c.extendedDisplayValues) ? {\n            accessor: function accessor(x) {\n              var values = c.accessor ? [(0, _lodash.get)(x, c.accessor)] : _jsonpath[\"default\"].query(x, c.jsonPath);\n              return values.map(function (x) {\n                return c.extendedDisplayValues[\"\".concat(x)] || x;\n              }).join(', ');\n            },\n            id: c.field\n          } : {\n            Cell: Cell\n          });\n        }, {}),\n        defaultPageSize: defaultPageSize,\n        PaginationComponent: function PaginationComponent(props) {\n          return _react[\"default\"].createElement(_CustomPagination[\"default\"], _extends({}, props, {\n            maxPagesOptions: maxPagesOptions\n          }));\n        }\n      }, checkboxProps, fetchFromServerProps)));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      return _objectSpread({}, prevState, {\n        selectedTableRows: nextProps.selectedTableRows || prevState.selectedTableRows\n      });\n    }\n  }]);\n\n  return DataTable;\n}(_react[\"default\"].Component);\n\nvar _default = enhance(DataTable);\n\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}