{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar _constants = require(\"../constants\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n} // _UNFLAT_KEY_ is a ephemeral mark for groupingOptimizer to not apply grouping\n\n\nvar _UNFLAT_KEY_ = '__unflat__';\n\nfunction groupingOptimizer(_ref) {\n  var op = _ref.op,\n      content = _ref.content,\n      pivot = _ref.pivot;\n  return {\n    op: op,\n    pivot: pivot,\n    content: content.map(normalizeFilters).reduce(function (filters, f) {\n      var samePivot = f.pivot === pivot || !f.pivot;\n\n      if (f.op === op && !f[_UNFLAT_KEY_] && samePivot) {\n        return [].concat(_toConsumableArray(filters), _toConsumableArray(f.content));\n      } else {\n        return [].concat(_toConsumableArray(filters), [(0, _lodash.omit)(f, _UNFLAT_KEY_)]);\n      }\n    }, [])\n  };\n}\n\nfunction isSpecialFilter(value) {\n  return [_constants.REGEX, _constants.SET_ID, _constants.MISSING].some(function (x) {\n    return \"\".concat(value).includes(x);\n  });\n}\n\nvar applyDefaultPivots = function applyDefaultPivots(filter) {\n  var content = filter.content,\n      _filter$pivot = filter.pivot,\n      pivot = _filter$pivot === void 0 ? null : _filter$pivot;\n  var value = content.value;\n\n  if (value) {\n    return _objectSpread({}, filter, {\n      pivot: pivot\n    });\n  } else {\n    return _objectSpread({}, filter, {\n      pivot: pivot,\n      content: filter.content.map(applyDefaultPivots)\n    });\n  }\n};\n\nfunction normalizeFilters(filter) {\n  var op = filter.op,\n      content = filter.content;\n\n  if (!op) {\n    throw Error(\"Must specify \\\"op\\\" in filters: \".concat(filter));\n  } else if (!content) {\n    throw Error(\"Must specify \\\"content\\\" in filters: \".concat(filter));\n  }\n\n  var value = content.value;\n\n  if (_constants.OP_ALIASES[op]) {\n    return normalizeFilters(_objectSpread({}, filter, {\n      op: _constants.OP_ALIASES[op]\n    }));\n  } else if (_constants.ARRAY_CONTENT.includes(op) && !Array.isArray(value)) {\n    return normalizeFilters(_objectSpread({}, filter, {\n      content: _objectSpread({}, content, {\n        value: [].concat(value)\n      })\n    }));\n  } else if ([_constants.IN_OP, _constants.NOT_IN_OP].includes(op) && value.some(isSpecialFilter) && value.length > 1) {\n    // Separate filters with special handling into separate filters and \"or\" them with the normal filter\n    var specialFilters = value.filter(isSpecialFilter).map(function (specialValue) {\n      return _objectSpread({}, filter, {\n        content: _objectSpread({}, content, {\n          value: [specialValue]\n        })\n      });\n    });\n    var normalValues = value.filter(function (psv) {\n      return !isSpecialFilter(psv);\n    });\n    var filters = normalValues.length > 0 ? [_objectSpread({}, filter, {\n      content: _objectSpread({}, content, {\n        value: normalValues\n      })\n    })].concat(_toConsumableArray(specialFilters)) : specialFilters;\n    return normalizeFilters({\n      op: _constants.OR_OP,\n      content: filters\n    });\n  } else if ([_constants.AND_OP, _constants.OR_OP, _constants.NOT_OP].includes(op)) {\n    return groupingOptimizer(filter);\n  } else {\n    return filter;\n  }\n}\n\nvar _default = function _default(filter) {\n  var output = filter ? applyDefaultPivots(normalizeFilters(filter)) : filter;\n  return output;\n};\n\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}