{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar _constants = require(\"../constants\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar MAX_AGGREGATION_SIZE = 300000;\nvar HISTOGRAM_INTERVAL_DEFAULT = 1000;\n\nvar createNumericAggregation = function createNumericAggregation(_ref) {\n  var type = _ref.type,\n      field = _ref.field,\n      graphqlField = _ref.graphqlField;\n  var args = (0, _lodash.get)(graphqlField, [type, '__arguments', 0]) || {};\n  return _defineProperty({}, \"\".concat(field, \":\").concat(type), _defineProperty({}, type, _objectSpread({\n    field: field\n  }, type === _constants.HISTOGRAM ? {\n    interval: (0, _lodash.get)(args, 'interval.value') || HISTOGRAM_INTERVAL_DEFAULT\n  } : {})));\n};\n\nvar createTermAggregation = function createTermAggregation(_ref3) {\n  var _ref4;\n\n  var field = _ref3.field,\n      isNested = _ref3.isNested;\n  return _ref4 = {}, _defineProperty(_ref4, field, _objectSpread({}, isNested ? {\n    aggs: {\n      rn: {\n        reverse_nested: {}\n      }\n    }\n  } : {}, {\n    terms: {\n      field: field,\n      size: MAX_AGGREGATION_SIZE\n    }\n  })), _defineProperty(_ref4, \"\".concat(field, \":missing\"), _objectSpread({}, isNested ? {\n    aggs: {\n      rn: {\n        reverse_nested: {}\n      }\n    }\n  } : {}, {\n    missing: {\n      field: field\n    }\n  })), _ref4;\n};\n/**\n * graphqlFields: output from `graphql-fields` (https://github.com/robrichard/graphql-fields)\n */\n\n\nvar _default = function _default(_ref5) {\n  var field = _ref5.field,\n      _ref5$graphqlField = _ref5.graphqlField,\n      graphqlField = _ref5$graphqlField === void 0 ? {} : _ref5$graphqlField,\n      _ref5$isNested = _ref5.isNested,\n      isNested = _ref5$isNested === void 0 ? false : _ref5$isNested;\n  var types = [_constants.BUCKETS, _constants.STATS, _constants.HISTOGRAM].filter(function (t) {\n    return graphqlField[t];\n  });\n  return types.reduce(function (acc, type) {\n    if (type === _constants.BUCKETS) {\n      return Object.assign(acc, createTermAggregation({\n        field: field,\n        isNested: isNested\n      }));\n    } else if ([_constants.STATS, _constants.HISTOGRAM].includes(type)) {\n      return Object.assign(acc, createNumericAggregation({\n        type: type,\n        field: field,\n        graphqlField: graphqlField\n      }));\n    } else {\n      return acc;\n    }\n  }, {});\n};\n\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}