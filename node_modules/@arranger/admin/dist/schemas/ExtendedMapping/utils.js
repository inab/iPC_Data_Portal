"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const mapping_utils_1 = require("@arranger/mapping-utils");
const elasticsearch_1 = require("../../services/elasticsearch");
const apollo_server_1 = require("apollo-server");
const utils_1 = require("../IndexSchema/utils");
const services_1 = require("../../services");
exports.createExtendedMapping = (es) => ({ esIndex, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let extendedMappings = [];
    try {
        const esMapping = yield elasticsearch_1.getEsMapping(es)({ esIndex });
        const indexName = Object.keys(esMapping)[0];
        const esMappingProperties = esMapping[indexName].mappings.properties;
        extendedMappings = mapping_utils_1.extendMapping(esMappingProperties);
    }
    catch (err) {
        console.log('error: ', err);
        throw err;
    }
    return extendedMappings;
});
exports.getExtendedMapping = (es) => ({ projectId, graphqlField, field, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const assertOutputType = (i) => ({
        gqlId: `${projectId}::${graphqlField}::extended::${i.field}`,
        field: i.field,
        type: i.type,
        displayName: i.displayName,
        active: i.active,
        isArray: i.isArray,
        primaryKey: i.primaryKey,
        quickSearchEnabled: i.quickSearchEnabled,
        unit: i.unit,
        displayValues: i.displayValues,
        rangeStep: i.rangeStep,
    });
    const indexMetadata = (yield utils_1.getProjectStorageMetadata(es)(projectId)).find(metaData => metaData.name === graphqlField);
    if (indexMetadata) {
        if (field) {
            return indexMetadata.config.extended
                .filter(ex => field === ex.field)
                .map(assertOutputType);
        }
        else {
            return indexMetadata.config.extended.map(assertOutputType);
        }
    }
    else {
        throw new apollo_server_1.UserInputError(`no index found under name ${graphqlField} for project ${projectId}`);
    }
});
exports.updateFieldExtendedMapping = (es) => ({ field: mutatedField, graphqlField, projectId, extendedFieldMappingInput, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const currentIndexMetadata = (yield utils_1.getProjectStorageMetadata(es)(projectId)).find(metaData => {
        return metaData.name === graphqlField;
    });
    if (currentIndexMetadata) {
        const indexExtendedMappingFields = yield exports.getExtendedMapping(es)({
            projectId,
            graphqlField,
        });
        const newIndexExtendedMappingFields = indexExtendedMappingFields.map(field => field.field === mutatedField
            ? Object.assign(Object.assign({}, field), extendedFieldMappingInput) : field);
        yield utils_1.updateProjectIndexMetadata(es)({
            projectId,
            metaData: {
                index: currentIndexMetadata.index,
                name: currentIndexMetadata.name,
                config: {
                    extended: newIndexExtendedMappingFields,
                },
            },
        });
        return newIndexExtendedMappingFields.find(field => field.field === mutatedField);
    }
    else {
        throw new apollo_server_1.UserInputError(`no index found under name ${graphqlField} for project ${projectId}`);
    }
});
exports.saveExtendedMapping = (es) => (args) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { projectId, graphqlField, input } = args;
    const currentIndexMetadata = (yield utils_1.getProjectStorageMetadata(es)(projectId)).find(entry => entry.name === graphqlField);
    const { config: { extended: currentStoredExtendedMapping }, } = currentIndexMetadata;
    const newExtendedMapping = services_1.replaceBy(currentStoredExtendedMapping, input, (el1, el2) => el1.field === el2.field);
    yield utils_1.updateProjectIndexMetadata(es)({
        projectId,
        metaData: {
            index: currentIndexMetadata.index,
            name: currentIndexMetadata.name,
            config: {
                extended: newExtendedMapping,
            },
        },
    });
    return newExtendedMapping;
});
//# sourceMappingURL=utils.js.map