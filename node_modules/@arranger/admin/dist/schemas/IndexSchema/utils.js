"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const apollo_server_1 = require("apollo-server");
const elasticsearch_1 = require("../../services/elasticsearch");
const constants_1 = require("../../services/constants");
const services_1 = require("../../services");
const utils_1 = require("../ExtendedMapping/utils");
const utils_2 = require("../ProjectSchema/utils");
const utils_3 = require("../ColumnsState/utils");
const utils_4 = require("../AggsState/utils");
const utils_5 = require("../MatchboxState/utils");
const Qew = require("qew");
const { ARRANGER_PROJECT_INDEX } = constants_1.constants;
exports.getProjectMetadataEsLocation = (projectId) => ({
    index: `${ARRANGER_PROJECT_INDEX}-${projectId}`,
});
const mappingExistsOn = (es) => ({ esIndex, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        yield elasticsearch_1.getEsMapping(es)({ esIndex });
        return true;
    }
    catch (err) {
        return false;
    }
});
exports.getProjectStorageMetadata = (es) => (projectId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const { body: { hits: { hits }, }, } = yield es.search(Object.assign({}, exports.getProjectMetadataEsLocation(projectId)));
        return hits.map(({ _source }) => _source);
    }
    catch (err) {
        throw new apollo_server_1.UserInputError(`cannot find project of id ${projectId}`, err);
    }
});
exports.getProjectMetadata = (es) => (projectId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return Promise.all((yield exports.getProjectStorageMetadata(es)(projectId)).map((metadata) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        return ({
            id: `${projectId}::${metadata.name}`,
            hasMapping: mappingExistsOn(es)({
                esIndex: metadata.index,
            }),
            graphqlField: metadata.name,
            projectId: projectId,
            esIndex: metadata.index,
        });
    })));
});
exports.createNewIndex = (es) => (args) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { projectId, graphqlField, esIndex } = args;
    const arrangerProject = (yield utils_2.getArrangerProjects(es)).find(project => project.id === projectId);
    if (arrangerProject) {
        const serializedGqlField = services_1.serializeToGqlField(graphqlField);
        const extendedMapping = yield utils_1.createExtendedMapping(es)({
            esIndex,
        });
        const metadataContent = {
            index: esIndex,
            name: serializedGqlField,
            timestamp: services_1.timestamp(),
            active: true,
            config: {
                'aggs-state': yield utils_4.createAggsSetState(es)({ esIndex }),
                'columns-state': yield utils_3.createColumnSetState(es)({
                    esIndex,
                }, graphqlField),
                'matchbox-state': utils_5.createMatchboxState({
                    graphqlField,
                    extendedFields: extendedMapping,
                }),
                extended: extendedMapping,
            },
        };
        yield es.create(Object.assign(Object.assign({}, exports.getProjectMetadataEsLocation(projectId)), { id: esIndex, body: metadataContent, refresh: 'true' }));
        return exports.getProjectIndex(es)({
            projectId,
            graphqlField: serializedGqlField,
        });
    }
    else {
        throw new apollo_server_1.UserInputError(`no project with ID ${projectId} was found`);
    }
});
const createProjectQueueManager = () => {
    const queues = {};
    return {
        getQueue: (projectId) => {
            if (!queues[projectId]) {
                queues[projectId] = new Qew(1);
            }
            return queues[projectId];
        },
    };
};
const projectQueueManager = createProjectQueueManager();
exports.updateProjectIndexMetadata = (es) => ({ projectId, metaData, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const queue = projectQueueManager.getQueue(projectId);
    return queue.pushProm(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        yield es.update(Object.assign(Object.assign({}, exports.getProjectMetadataEsLocation(projectId)), { id: metaData.index, body: {
                doc: metaData,
            }, refresh: 'true' }));
        const output = (yield exports.getProjectStorageMetadata(es)(projectId)).find(i => i.name === metaData.name);
        return output;
    }));
});
exports.getProjectIndex = (es) => ({ projectId, graphqlField, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const output = (yield exports.getProjectMetadata(es)(projectId)).find(({ graphqlField: _graphqlField }) => graphqlField === _graphqlField);
        return output;
    }
    catch (_a) {
        throw new apollo_server_1.UserInputError(`could not find index ${graphqlField} of project ${projectId}`);
    }
});
exports.removeProjectIndex = (es) => ({ projectId, graphqlField, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const removedIndexMetadata = yield exports.getProjectIndex(es)({
            projectId,
            graphqlField,
        });
        yield es.delete(Object.assign(Object.assign({}, exports.getProjectMetadataEsLocation(projectId)), { id: removedIndexMetadata.esIndex, refresh: 'true' }));
        return removedIndexMetadata;
    }
    catch (err) {
        throw new apollo_server_1.UserInputError(`could not remove index ${graphqlField} of project ${projectId}`);
    }
});
//# sourceMappingURL=utils.js.map