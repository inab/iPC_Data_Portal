"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _lodash = require("lodash");

var _constants = require("../constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

// _UNFLAT_KEY_ is a ephemeral mark for groupingOptimizer to not apply grouping
var _UNFLAT_KEY_ = '__unflat__';

function groupingOptimizer(_ref) {
  var op = _ref.op,
      content = _ref.content,
      pivot = _ref.pivot;
  return {
    op: op,
    pivot: pivot,
    content: content.map(normalizeFilters).reduce(function (filters, f) {
      var samePivot = f.pivot === pivot || !f.pivot;

      if (f.op === op && !f[_UNFLAT_KEY_] && samePivot) {
        return [].concat(_toConsumableArray(filters), _toConsumableArray(f.content));
      } else {
        return [].concat(_toConsumableArray(filters), [(0, _lodash.omit)(f, _UNFLAT_KEY_)]);
      }
    }, [])
  };
}

function isSpecialFilter(value) {
  return [_constants.REGEX, _constants.SET_ID, _constants.MISSING].some(function (x) {
    return "".concat(value).includes(x);
  });
}

var applyDefaultPivots = function applyDefaultPivots(filter) {
  var content = filter.content,
      _filter$pivot = filter.pivot,
      pivot = _filter$pivot === void 0 ? null : _filter$pivot;
  var value = content.value;

  if (value) {
    return _objectSpread({}, filter, {
      pivot: pivot
    });
  } else {
    return _objectSpread({}, filter, {
      pivot: pivot,
      content: filter.content.map(applyDefaultPivots)
    });
  }
};

function normalizeFilters(filter) {
  var op = filter.op,
      content = filter.content;

  if (!op) {
    throw Error("Must specify \"op\" in filters: ".concat(filter));
  } else if (!content) {
    throw Error("Must specify \"content\" in filters: ".concat(filter));
  }

  var value = content.value;

  if (_constants.OP_ALIASES[op]) {
    return normalizeFilters(_objectSpread({}, filter, {
      op: _constants.OP_ALIASES[op]
    }));
  } else if (_constants.ARRAY_CONTENT.includes(op) && !Array.isArray(value)) {
    return normalizeFilters(_objectSpread({}, filter, {
      content: _objectSpread({}, content, {
        value: [].concat(value)
      })
    }));
  } else if ([_constants.IN_OP, _constants.NOT_IN_OP].includes(op) && value.some(isSpecialFilter) && value.length > 1) {
    // Separate filters with special handling into separate filters and "or" them with the normal filter
    var specialFilters = value.filter(isSpecialFilter).map(function (specialValue) {
      return _objectSpread({}, filter, {
        content: _objectSpread({}, content, {
          value: [specialValue]
        })
      });
    });
    var normalValues = value.filter(function (psv) {
      return !isSpecialFilter(psv);
    });
    var filters = normalValues.length > 0 ? [_objectSpread({}, filter, {
      content: _objectSpread({}, content, {
        value: normalValues
      })
    })].concat(_toConsumableArray(specialFilters)) : specialFilters;
    return normalizeFilters({
      op: _constants.OR_OP,
      content: filters
    });
  } else if ([_constants.AND_OP, _constants.OR_OP, _constants.NOT_OP].includes(op)) {
    return groupingOptimizer(filter);
  } else {
    return filter;
  }
}

var _default = function _default(filter) {
  var output = filter ? applyDefaultPivots(normalizeFilters(filter)) : filter;
  return output;
};

exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9idWlsZFF1ZXJ5L25vcm1hbGl6ZUZpbHRlcnMuanMiXSwibmFtZXMiOlsiX1VORkxBVF9LRVlfIiwiZ3JvdXBpbmdPcHRpbWl6ZXIiLCJvcCIsImNvbnRlbnQiLCJwaXZvdCIsIm1hcCIsIm5vcm1hbGl6ZUZpbHRlcnMiLCJyZWR1Y2UiLCJmaWx0ZXJzIiwiZiIsInNhbWVQaXZvdCIsImlzU3BlY2lhbEZpbHRlciIsInZhbHVlIiwiUkVHRVgiLCJTRVRfSUQiLCJNSVNTSU5HIiwic29tZSIsIngiLCJpbmNsdWRlcyIsImFwcGx5RGVmYXVsdFBpdm90cyIsImZpbHRlciIsIkVycm9yIiwiT1BfQUxJQVNFUyIsIkFSUkFZX0NPTlRFTlQiLCJBcnJheSIsImlzQXJyYXkiLCJjb25jYXQiLCJJTl9PUCIsIk5PVF9JTl9PUCIsImxlbmd0aCIsInNwZWNpYWxGaWx0ZXJzIiwic3BlY2lhbFZhbHVlIiwibm9ybWFsVmFsdWVzIiwicHN2IiwiT1JfT1AiLCJBTkRfT1AiLCJOT1RfT1AiLCJvdXRwdXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0EsSUFBTUEsWUFBWSxHQUFHLFlBQXJCOztBQUNBLFNBQVNDLGlCQUFULE9BQW1EO0FBQUEsTUFBdEJDLEVBQXNCLFFBQXRCQSxFQUFzQjtBQUFBLE1BQWxCQyxPQUFrQixRQUFsQkEsT0FBa0I7QUFBQSxNQUFUQyxLQUFTLFFBQVRBLEtBQVM7QUFDakQsU0FBTztBQUNMRixJQUFBQSxFQUFFLEVBQUZBLEVBREs7QUFFTEUsSUFBQUEsS0FBSyxFQUFMQSxLQUZLO0FBR0xELElBQUFBLE9BQU8sRUFBRUEsT0FBTyxDQUFDRSxHQUFSLENBQVlDLGdCQUFaLEVBQThCQyxNQUE5QixDQUFxQyxVQUFDQyxPQUFELEVBQVVDLENBQVYsRUFBZ0I7QUFDNUQsVUFBTUMsU0FBUyxHQUFHRCxDQUFDLENBQUNMLEtBQUYsS0FBWUEsS0FBWixJQUFxQixDQUFDSyxD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T0FBUDtBQUFnQlMsVUFBQUEsS0FBSyxFQUFFLENBQUNtQixZQUFEO0FBQXZCO0FBRjREO0FBQUEsS0FBOUMsQ0FBdkI7QUFLQSxRQUFNQyxZQUFZLEdBQUdwQixLQUFLLENBQUNRLE1BQU4sQ0FBYSxVQUFBYSxHQUFHO0FBQUEsYUFBSSxDQUFDdEIsZUFBZSxDQUFDc0IsR0FBRCxDQUFwQjtBQUFBLEtBQWhCLENBQXJCO0FBQ0EsUUFBTXpCLE9BQU8sR0FDWHdCLFlBQVksQ0FBQ0gsTUFBYixHQUFzQixDQUF0QixzQkFFV1QsTUFGWDtBQUVtQmpCLE1BQUFBLE9BQU8sb0JBQU9BLE9BQVA7QUFBZ0JTLFFBQUFBLEtBQUssRUFBRW9CO0FBQXZCO0FBRjFCLGtDQUdTRixjQUhULEtBS0lBLGNBTk47QUFRQSxXQUFPeEIsZ0JBQWdCLENBQUM7QUFBRUosTUFBQUEsRUFBRSxFQUFFZ0MsZ0JBQU47QUFBYS9CLE1BQUFBLE9BQU8sRUFBRUs7QUFBdEIsS0FBRCxDQUF2QjtBQUNELEdBckJNLE1BcUJBLElBQUksQ0FBQzJCLGlCQUFELEVBQVNELGdCQUFULEVBQWdCRSxpQkFBaEIsRUFBd0JsQixRQUF4QixDQUFpQ2hCLEVBQWpDLENBQUosRUFBMEM7QUFDL0MsV0FBT0QsaUJBQWlCLENBQUNtQixNQUFELENBQXhCO0FBQ0QsR0FGTSxNQUVBO0FBQ0wsV0FBT0EsTUFBUDtBQUNEO0FBQ0Y7O2VBRWMsa0JBQUFBLE1BQU0sRUFBSTtBQUN2QixNQUFNaUIsTUFBTSxHQUFHakIsTUFBTSxHQUFHRCxrQkFBa0IsQ0FBQ2IsZ0JBQWdCLENBQUNjLE1BQUQsQ0FBakIsQ0FBckIsR0FBa0RBLE1BQXZFO0FBQ0EsU0FBT2lCLE1BQVA7QUFDRCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb21pdCwgaXNBcnJheSwgbWluLCBtYXggfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgSU5fT1AsXG4gIE5PVF9JTl9PUCxcbiAgT1JfT1AsXG4gIEFORF9PUCxcbiAgTk9UX09QLFxuICBPUF9BTElBU0VTLFxuICBBUlJBWV9DT05URU5ULFxuICBSRUdFWCxcbiAgU0VUX0lELFxuICBNSVNTSU5HLFxuICBBTExfT1AsXG59IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbi8vIF9VTkZMQVRfS0VZXyBpcyBhIGVwaGVtZXJhbCBtYXJrIGZvciBncm91cGluZ09wdGltaXplciB0byBub3QgYXBwbHkgZ3JvdXBpbmdcbmNvbnN0IF9VTkZMQVRfS0VZXyA9ICdfX3VuZmxhdF9fJztcbmZ1bmN0aW9uIGdyb3VwaW5nT3B0aW1pemVyKHsgb3AsIGNvbnRlbnQsIHBpdm90IH0pIHtcbiAgcmV0dXJuIHtcbiAgICBvcCxcbiAgICBwaXZvdCxcbiAgICBjb250ZW50OiBjb250ZW50Lm1hcChub3JtYWxpemVGaWx0ZXJzKS5yZWR1Y2UoKGZpbHRlcnMsIGYpID0+IHtcbiAgICAgIGNvbnN0IHNhbWVQaXZvdCA9IGYucGl2b3QgPT09IHBpdm90IHx8ICFmLnBpdm90O1xuICAgICAgaWYgKGYub3AgPT09IG9wICYmICFmW19VTkZMQVRfS0VZX10gJiYgc2FtZVBpdm90KSB7XG4gICAgICAgIHJldHVybiBbLi4uZmlsdGVycywgLi4uZi5jb250ZW50XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbLi4uZmlsdGVycywgb21pdChmLCBfVU5GTEFUX0tFWV8pXTtcbiAgICAgIH1cbiAgICB9LCBbXSksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbEZpbHRlcih2YWx1ZSkge1xuICByZXR1cm4gW1JFR0VYLCBTRVRfSUQsIE1JU1NJTkddLnNvbWUoeCA9PiBgJHt2YWx1ZX1gLmluY2x1ZGVzKHgpKTtcbn1cblxuY29uc3QgYXBwbHlEZWZhdWx0UGl2b3RzID0gZmlsdGVyID0+IHtcbiAgY29uc3QgeyBjb250ZW50LCBwaXZvdCA9IG51bGwgfSA9IGZpbHRlcjtcbiAgY29uc3QgeyB2YWx1ZSB9ID0gY29udGVudDtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZpbHRlcixcbiAgICAgIHBpdm90LFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZpbHRlcixcbiAgICAgIHBpdm90LFxuICAgICAgY29udGVudDogZmlsdGVyLmNvbnRlbnQubWFwKGFwcGx5RGVmYXVsdFBpdm90cyksXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRmlsdGVycyhmaWx0ZXIpIHtcbiAgY29uc3QgeyBvcCwgY29udGVudCB9ID0gZmlsdGVyO1xuXG4gIGlmICghb3ApIHtcbiAgICB0aHJvdyBFcnJvcihgTXVzdCBzcGVjaWZ5IFwib3BcIiBpbiBmaWx0ZXJzOiAke2ZpbHRlcn1gKTtcbiAgfSBlbHNlIGlmICghY29udGVudCkge1xuICAgIHRocm93IEVycm9yKGBNdXN0IHNwZWNpZnkgXCJjb250ZW50XCIgaW4gZmlsdGVyczogJHtmaWx0ZXJ9YCk7XG4gIH1cblxuICBjb25zdCB7IHZhbHVlIH0gPSBjb250ZW50O1xuICBpZiAoT1BfQUxJQVNFU1tvcF0pIHtcbiAgICByZXR1cm4gbm9ybWFsaXplRmlsdGVycyh7IC4uLmZpbHRlciwgb3A6IE9QX0FMSUFTRVNbb3BdIH0pO1xuICB9IGVsc2UgaWYgKEFSUkFZX0NPTlRFTlQuaW5jbHVkZXMob3ApICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBub3JtYWxpemVGaWx0ZXJzKHtcbiAgICAgIC4uLmZpbHRlcixcbiAgICAgIGNvbnRlbnQ6IHsgLi4uY29udGVudCwgdmFsdWU6IFtdLmNvbmNhdCh2YWx1ZSkgfSxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChcbiAgICBbSU5fT1AsIE5PVF9JTl9PUF0uaW5jbHVkZXMob3ApICYmXG4gICAgdmFsdWUuc29tZShpc1NwZWNpYWxGaWx0ZXIpICYmXG4gICAgdmFsdWUubGVuZ3RoID4gMVxuICApIHtcbiAgICAvLyBTZXBhcmF0ZSBmaWx0ZXJzIHdpdGggc3BlY2lhbCBoYW5kbGluZyBpbnRvIHNlcGFyYXRlIGZpbHRlcnMgYW5kIFwib3JcIiB0aGVtIHdpdGggdGhlIG5vcm1hbCBmaWx0ZXJcbiAgICBjb25zdCBzcGVjaWFsRmlsdGVycyA9IHZhbHVlLmZpbHRlcihpc1NwZWNpYWxGaWx0ZXIpLm1hcChzcGVjaWFsVmFsdWUgPT4gKHtcbiAgICAgIC4uLmZpbHRlcixcbiAgICAgIGNvbnRlbnQ6IHsgLi4uY29udGVudCwgdmFsdWU6IFtzcGVjaWFsVmFsdWVdIH0sXG4gICAgfSkpO1xuXG4gICAgY29uc3Qgbm9ybWFsVmFsdWVzID0gdmFsdWUuZmlsdGVyKHBzdiA9PiAhaXNTcGVjaWFsRmlsdGVyKHBzdikpO1xuICAgIGNvbnN0IGZpbHRlcnMgPVxuICAgICAgbm9ybWFsVmFsdWVzLmxlbmd0aCA+IDBcbiAgICAgICAgPyBbXG4gICAgICAgICAgICB7IC4uLmZpbHRlciwgY29udGVudDogeyAuLi5jb250ZW50LCB2YWx1ZTogbm9ybWFsVmFsdWVzIH0gfSxcbiAgICAgICAgICAgIC4uLnNwZWNpYWxGaWx0ZXJzLFxuICAgICAgICAgIF1cbiAgICAgICAgOiBzcGVjaWFsRmlsdGVycztcblxuICAgIHJldHVybiBub3JtYWxpemVGaWx0ZXJzKHsgb3A6IE9SX09QLCBjb250ZW50OiBmaWx0ZXJzIH0pO1xuICB9IGVsc2UgaWYgKFtBTkRfT1AsIE9SX09QLCBOT1RfT1BdLmluY2x1ZGVzKG9wKSkge1xuICAgIHJldHVybiBncm91cGluZ09wdGltaXplcihmaWx0ZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZmlsdGVyID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gZmlsdGVyID8gYXBwbHlEZWZhdWx0UGl2b3RzKG5vcm1hbGl6ZUZpbHRlcnMoZmlsdGVyKSkgOiBmaWx0ZXI7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuIl19