"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.hitsToEdges = void 0;

var _graphqlFields = _interopRequireDefault(require("graphql-fields"));

var _middleware = require("@arranger/middleware");

var _lodash = require("lodash");

var _esSearch = _interopRequireDefault(require("./utils/esSearch"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var findCopyToSourceFields = function findCopyToSourceFields(mapping) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.entries(mapping).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        k = _ref2[0],
        v = _ref2[1];

    if (v.type === 'nested') {
      findCopyToSourceFields(v.properties, k, results);
    } else if (Object.keys(v).includes('copy_to')) {
      var fullPath = path ? "".concat(path, ".").concat(k) : k;
      var copy_to = v.copy_to[0];
      results[copy_to] = [].concat(_toConsumableArray(results[copy_to] || []), [fullPath]);
    }
  });
  return results;
};

var hitsToEdges = function hitsToEdges(_ref3) {
  var _process, _process$env;

  var hits = _ref3.hits,
      nestedFields = _ref3.nestedFields,
      Parallel = _ref3.Parallel,
      _ref3$copyToSourceFie = _ref3.copyToSourceFields,
      copyToSourceFields = _ref3$copyToSourceFie === void 0 ? {} : _ref3$copyToSourceFie,
      _ref3$systemCores = _ref3.systemCores,
      systemCores = _ref3$systemCores === void 0 ? ((_process = process) === null || _process === void 0 ? void 0 : (_process$env = _process.env) === null || _process$env === void 0 ? void 0 : _process$env.SYSTEM_CORES) || 2 : _ref3$systemCores;

  /*
    If there's a large request, we'll trigger ludicrous mode and do some parallel
    map-reduce based on # of cores available. Otherwise, only one child-process
    is spawn for compute
  */
  var dataSize = hits.hits.length;
  var chunks = (0, _lodash.chunk)(hits.hits, dataSize > 1000 ? dataSize / systemCores + dataSize % systemCores : dataSize);
  return Promise.all(chunks.map(function (chunk) {
    return (//Parallel.spawn output has a .then but it's not returning an actual promise
      new Promise(function (resolve) {
        new Parallel({
          hits: chunk,
          nestedFields: nestedFields,
          copyToSourceFields: copyToSourceFields
        }).spawn(function (_ref4) {
          var hits = _ref4.hits,
              nestedFields = _ref4.nestedFields,
              copyToSourceFields = _ref4.copyToSourceFields;

          /*
            everthing inside spawn is executed in a separate thread, so we have
            to use good old ES5 and require for run-time dependecy bundling.
          */
          var _require = require('lodash'),
              isObject = _require.isObject,
              flattenDeep = _require.flattenDeep;

          var jp = require('jsonpath/jsonpath.min');

          var resolveCopiedTo = function resolveCopiedTo(_ref5) {
            var node = _ref5.node;
            var foundValues = Object.entries(copyToSourceFields).reduce(function (acc, pair) {
              var copyToField = pair[0];
              var sourceField = pair[1];
              var found = {};
              found[copyToField] = flattenDeep(sourceField.map(function (path) {
                return jp.query(node, path.split('.').reduce(function (acc, part, index) {
                  return index === 0 ? "$.".concat(part) : "".concat(acc, "..").concat(part);
                }, ''));
              }));
              return found;
            }, {});
            return foundValues;
          };

          return hits.map(function (x) {
            var joinParent = function joinParent(parent, field) {
              return parent ? "".concat(parent, ".").concat(field) : field;
            };

            var resolveNested = function resolveNested(_ref6) {
              var node = _ref6.node,
                  nestedFields = _ref6.nestedFields,
                  _ref6$parent = _ref6.parent,
                  parent = _ref6$parent === void 0 ? '' : _ref6$parent;
              if (!isObject(node) || !node) return node;
              return Object.entries(node).reduce(function (acc, pair) {
                var field = pair[0];
                var hits = pair[1]; // TODO: inner hits query if necessary

                var fullPath = joinParent(parent, field);
                acc[field] = nestedFields.includes(fullPath) ? {
                  hits: {
                    edges: hits.map(function (node) {
                      return {
                        node: Object.assign({}, node, resolveNested({
                          node: node,
                          nestedFields: nestedFields,
                          parent: fullPath
                        }))
                      };
                    }),
                    total: hits.length
                  }
                } : isObject(hits) && hits ? Object.assign(hits.constructor(), resolveNested({
                  node: hits,
                  nestedFields: nestedFields,
                  parent: fullPath
                })) : resolveNested({
                  node: hits,
                  nestedFields: nestedFields,
                  parent: fullPath
                });
                return acc;
              }, {});
            };

            var source = x._source;
            var nested_nodes = resolveNested({
              node: source,
              nestedFields: nestedFields
            });
            var copied_to_nodes = resolveCopiedTo({
              node: source
            });
            return {
              searchAfter: x.sort ? x.sort.map(function (x) {
                return Number.isInteger(x) && !Number.isSafeInteger(x) ? // TODO: figure out a way to inject ES_CONSTANTS in here from @arranger/middleware
                // ? ES_CONSTANTS.ES_MAX_LONG //https://github.com/elastic/elasticsearch-js/issues/662
                "-9223372036854775808" //https://github.com/elastic/elasticsearch-js/issues/662
                : x;
              }) : [],
              node: Object.assign(source, // we're not afraid of mutating source here!
              {
                id: x._id
              }, nested_nodes, copied_to_nodes)
            };
          });
        }).then(resolve);
      })
    );
  })).then(function (chunks) {
    return chunks.reduce(function (acc, chunk) {
      return acc.concat(chunk);
    }, []);
  });
};

exports.hitsToEdges = hitsToEdges;

var _default = function _default(_ref7) {
  var type = _ref7.type,
      Parallel = _ref7.Parallel;
  return (
    /*#__PURE__*/
    function () {
      var _ref10 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(obj, _ref8, _ref9, info) {
        var _ref8$first, first, _ref8$offset, offset, filters, score, sort, searchAfter, es, fields, nestedFields, query, body, copyToSourceFields, _ref13, hits;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref8$first = _ref8.first, first = _ref8$first === void 0 ? 10 : _ref8$first, _ref8$offset = _ref8.offset, offset = _ref8$offset === void 0 ? 0 : _ref8$offset, filters = _ref8.filters, score = _ref8.score, sort = _ref8.sort, searchAfter = _ref8.searchAfter;
                es = _ref9.es;
                fields = (0, _graphqlFields["default"])(info);
                nestedFields = type.nested_fields;
                query = filters;

                if (filters || score) {
                  // TODO: something with score?
                  query = (0, _middleware.buildQuery)({
                    nestedFields: nestedFields,
                    filters: filters
                  });
                }

                body = query && {
                  query: query
                } || {};

                if (sort && sort.length) {
                  // TODO: add query here to sort based on result. https://www.elastic.co/guide/en/elasticsearch/guide/current/nested-sorting.html
                  body.sort = sort.map(function (_ref11) {
                    var field = _ref11.field,
                        missing = _ref11.missing,
                        order = _ref11.order,
                        rest = _objectWithoutProperties(_ref11, ["field", "missing", "order"]);

                    var nested_path = nestedFields.filter(function (nestedField) {
                      return field.indexOf(nestedField) === 0;
                    }).reduce(function (deepestPath, path) {
                      return deepestPath.length > path.length ? deepestPath : path;
                    }, '');
                    return _defineProperty({}, field, _objectSpread({
                      missing: missing ? missing === 'first' ? '_first' : '_last' : order === 'asc' ? '_first' : '_last',
                      order: order
                    }, rest, {}, (nested_path === null || nested_path === void 0 ? void 0 : nested_path.length) ? {
                      nested: {
                        path: nested_path
                      }
                    } : {}));
                  });
                }

                if (searchAfter) {
                  body.search_after = searchAfter;
                }

                copyToSourceFields = findCopyToSourceFields(type.mapping);
                _context.next = 12;
                return (0, _esSearch["default"])(es)({
                  index: type.index,
                  size: first,
                  from: offset,
                  _source: [].concat(_toConsumableArray(fields.edges && Object.keys(fields.edges.node || {}) || []), _toConsumableArray(Object.values(copyToSourceFields))),
                  track_scores: !!score,
                  body: body
                });

              case 12:
                _ref13 = _context.sent;
                hits = _ref13.hits;
                return _context.abrupt("return", {
                  edges: function edges() {
                    return hitsToEdges({
                      hits: hits,
                      nestedFields: nestedFields,
                      Parallel: Parallel,
                      copyToSourceFields: copyToSourceFields
                    });
                  },
                  total: function total() {
                    return hits.total.value;
                  }
                });

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x, _x2, _x3, _x4) {
        return _ref10.apply(this, arguments);
      };
    }()
  );
};

exports["default"] = _default;