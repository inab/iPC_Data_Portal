"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolvers = exports.typeDefs = void 0;

var _graphqlTypeJson = _interopRequireDefault(require("graphql-type-json"));

var _graphqlScalars = require("graphql-scalars");

var _lodash = require("lodash");

var _paralleljs = _interopRequireDefault(require("paralleljs"));

var _mappingUtils = require("@arranger/mapping-utils");

var _Aggregations = require("./Aggregations");

var _Sets = require("./Sets");

var _Sort = require("./Sort");

var _State = require("./State");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var RootTypeDefs = function RootTypeDefs(_ref) {
  var types = _ref.types,
      rootTypes = _ref.rootTypes,
      scalarTypes = _ref.scalarTypes;
  return "\n  scalar JSON\n  scalar Date\n  enum EsRefresh {\n    TRUE\n    FALSE\n    WAIT_FOR\n  }\n\n  ".concat(scalarTypes.map(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 1),
        type = _ref3[0];

    return "scalar ".concat(type);
  }), "\n\n  interface Node {\n    id: ID!\n  }\n\n  type FileSize {\n    value: Float\n  }\n\n  type QueryResults {\n    total: Int\n    hits: [Node]\n  }\n\n  type Root {\n    node(id: ID!): Node\n    viewer: Root\n    query(query: String, types: [String]): QueryResults\n\n    ").concat(rootTypes.map(function (_ref4) {
    var _ref5 = _slicedToArray(_ref4, 1),
        key = _ref5[0];

    return "".concat(key, ": ").concat((0, _lodash.startCase)(key).replace(/\s/g, ''));
  }), "\n    ").concat(types.map(function (_ref6) {
    var _ref7 = _slicedToArray(_ref6, 2),
        key = _ref7[0],
        type = _ref7[1];

    return "".concat(type.name, ": ").concat(type.name);
  }), "\n  }\n\n  ").concat(rootTypes.map(function (_ref8) {
    var _ref9 = _slicedToArray(_ref8, 2),
        type = _ref9[1];

    return type.typeDefs;
  }), "\n\n  enum ProjectType {\n    ").concat(types.map(function (_ref10) {
    var _ref11 = _slicedToArray(_ref10, 2),
        key = _ref11[0],
        type = _ref11[1];

    return type.name;
  }).join('\n'), "\n  }\n\n  type Mutation {\n    saveSet(type: ProjectType! userId: String sqon: JSON! path: String! sort: [Sort] refresh: EsRefresh): Set\n  }\n\n  schema {\n    query: Root\n    mutation: Mutation\n  }\n");
};

var typeDefs = function typeDefs(_ref12) {
  var types = _ref12.types,
      rootTypes = _ref12.rootTypes,
      scalarTypes = _ref12.scalarTypes;
  return [RootTypeDefs({
    types: types,
    rootTypes: rootTypes,
    scalarTypes: scalarTypes
  }), _Aggregations.typeDefs, _Sets.typeDefs, _Sort.typeDefs, _State.typeDefs].concat(_toConsumableArray(types.map(function (_ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        key = _ref14[0],
        type = _ref14[1];

    return (0, _mappingUtils.mappingToFields)({
      type: type,
      parent: ''
    });
  })));
};

exports.typeDefs = typeDefs;

var resolveObject = function resolveObject() {
  return {};
};

var resolvers = function resolvers(_ref15) {
  var types = _ref15.types,
      rootTypes = _ref15.rootTypes,
      scalarTypes = _ref15.scalarTypes;
  return _objectSpread({
    JSON: _graphqlTypeJson["default"],
    Date: _graphqlScalars.GraphQLDate,
    Root: _objectSpread({
      viewer: resolveObject
    }, [].concat(_toConsumableArray(types), _toConsumableArray(rootTypes)).reduce(function (acc, _ref16) {
      var _ref17 = _slicedToArray(_ref16, 2),
          key = _ref17[0],
          type = _ref17[1];

      return _objectSpread({}, acc, _defineProperty({}, type.name || key, resolveObject));
    }, {}))
  }, types.reduce(function (acc, _ref18) {
    var _ref19 = _slicedToArray(_ref18, 2),
        key = _ref19[0],
        type = _ref19[1];

    return _objectSpread({}, acc, {}, (0, _mappingUtils.createConnectionResolvers)({
      type: type,
      createStateResolvers: 'createState' in type ? type.createState : true,
      Parallel: _paralleljs["default"]
    }));
  }, {}), {}, rootTypes.reduce(function (acc, _ref20) {
    var _ref21 = _slicedToArray(_ref20, 2),
        key = _ref21[0],
        type = _ref21[1];

    return _objectSpread({}, acc, {}, type.resolvers ? _defineProperty({}, (0, _lodash.startCase)(key).replace(/\s/g, ''), type.resolvers) : {});
  }, {}), {}, scalarTypes.reduce(function (acc, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 2),
        scalar = _ref24[0],
        resolver = _ref24[1];

    return _objectSpread({}, acc, _defineProperty({}, scalar, resolver));
  }, {}), {
    Mutation: {
      saveSet: (0, _mappingUtils.saveSet)({
        types: types
      })
    }
  });
};

exports.resolvers = resolvers;