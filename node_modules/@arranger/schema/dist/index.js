"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.setsMapping = exports.StateTypeDefs = void 0;

var _graphqlTools = require("graphql-tools");

var _graphqlMiddleware = require("graphql-middleware");

var _middleware = require("@arranger/middleware");

var _Root = require("./Root");

var _State = require("./State");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var StateTypeDefs = {
  AggsStateTypeDefs: _State.AggsStateTypeDefs,
  ColumnStateTypeDefs: _State.ColumnStateTypeDefs,
  MatchBoxStateTypeDefs: _State.MatchBoxStateTypeDefs
};
exports.StateTypeDefs = StateTypeDefs;
var setsMapping = {
  userId: {
    type: 'keyword'
  },
  sqon: {
    type: 'object'
  },
  ids: {
    type: 'keyword'
  },
  setId: {
    type: 'keyword'
  },
  type: {
    type: 'keyword'
  },
  path: {
    type: 'keyword'
  },
  size: {
    type: 'long'
  },
  createdAt: {
    type: 'date'
  }
};
exports.setsMapping = setsMapping;

var _default = function _default() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$types = _ref.types,
      types = _ref$types === void 0 ? [] : _ref$types,
      _ref$rootTypes = _ref.rootTypes,
      rootTypes = _ref$rootTypes === void 0 ? [] : _ref$rootTypes,
      _ref$scalarTypes = _ref.scalarTypes,
      scalarTypes = _ref$scalarTypes === void 0 ? [] : _ref$scalarTypes,
      _ref$middleware = _ref.middleware,
      middleware = _ref$middleware === void 0 ? [] : _ref$middleware,
      _ref$mock = _ref.mock,
      mock = _ref$mock === void 0 ? false : _ref$mock,
      enableAdmin = _ref.enableAdmin;

  var typesWithSets = [].concat(_toConsumableArray(types), [['sets', {
    index: _middleware.CONSTANTS.ES_ARRANGER_SET_TYPE,
    name: 'sets',
    createState: false,
    nestedFields: [],
    nested_fields: [],
    indexPrefix: '',
    customFields: '',
    extendedFields: [{
      active: false,
      displayName: 'ids',
      field: 'ids',
      isArray: true,
      type: 'keyword',
      unit: null
    }],
    mapping: setsMapping
  }]]);
  var typeDefs = (0, _Root.typeDefs)({
    types: typesWithSets,
    rootTypes: rootTypes,
    scalarTypes: scalarTypes,
    enableAdmin: enableAdmin
  });
  var resolvers = (0, _Root.resolvers)({
    types: typesWithSets,
    rootTypes: rootTypes,
    scalarTypes: scalarTypes,
    enableAdmin: enableAdmin
  });
  var schema = (0, _graphqlTools.makeExecutableSchema)({
    typeDefs: typeDefs,
    resolvers: resolvers,
    resolverValidationOptions: {
      // this disables a warning which we are ok with (https://github.com/prisma/prisma/issues/2225)
      requireResolversForResolveType: false
    }
  });

  if (mock) {
    (0, _graphqlTools.addMockFunctionsToSchema)({
      schema: schema,
      mocks: {
        JSON: function (_JSON) {
          function JSON() {
            return _JSON.apply(this, arguments);
          }

          JSON.toString = function () {
            return _JSON.toString();
          };

          return JSON;
        }(function () {
          return JSON.stringify({
            key: 'value'
          });
        })
      }
    });
  }

  return _graphqlMiddleware.applyMiddleware.apply(void 0, [schema].concat(_toConsumableArray(middleware)));
};

exports["default"] = _default;